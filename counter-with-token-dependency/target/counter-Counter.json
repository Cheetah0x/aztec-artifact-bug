{"transpiled":true,"noir_version":"0.33.0+8ac81b15cd2a3b57493bfbfe444086deac8f3dc8","name":"Counter","functions":[{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+xdB5xTRRM/rnN07A0PGyqWt0kuySkiKiIiTWmiqNylCFKlCYqICBbsvTfsnWbD3kVsYMPeQAULdlEUv1nY5w1huUvyZs43n3m/3/8ymc3b+8/O7mzNS4O8tVePlnl5XZuslRsACsxrPqA8Ree+YrnQoiu23NvYomtq0TW36FpadJsBOqTotrV8rtyia23RbWfR7WR0+GpgXjuY16ATDoUSkUBCBVWVE6isjlY4oYrqcFRFVUW0Ih6IBoOJaCgaqayujDiVKhRMqGRFZTDprL3uy6/Jy/F0BWKcPGdmzVOpVI3rv0LEVZfDaiO3yauRd0byTPMZ975Z8H42YA5gbn5NXUzNexbKezaS5yB5bkre98P7BwAPAh6qJe/7UR4PIPlBJD+UkvfD8H4e4BHAo7Xk/TDKYx6SH0Hyoyl5PwbvHwc8AXiylrwfQ3k8juQnkPxkSt5PwfunAc8Anq0l76dQHk8j+RkkP5uS93Pw/nnAC4AX82v0eShffXUwr17r83yydld3fX4OyfPzN1yfX4L3CwAvA16ppXxfQnksQPLLSH4lJe9X4f1rgNcBC2vJ+1WUx2tIfh3JC1PyXgTv3wC8CXirlrwXoTzeQPKbSH4rJe+34f07gMWAd2vJ+22UxztIXozkd1Pyfg/evw/4APBhLXm/h/J4H8kfIPnDlLw/gvcfAz4BfGqpz/nmtYN5dbxdaqc8urbxGV3bULg/1fmWM5cD5u61HD5nKofPTTkUpZSBOw6xXTQ8QpU8+YYTTPkGefKNBJj4VjDlGxfGl6k+REJMfKW1iwhPvgGHiS9TOw4nefKN5NrFWr5M5cAVf9nqb5gpX676K618ucqBKU6yxfVce1vLt5on3yAX37i7BoqvBqT/w1Ft6PJarxyshL1OoJYQT6Aa5q07WVqSv/6iob6W5q+dXDXKW98pHI5ZSryY5F5f5DMS1plT5/sl4eyby+4v82sKmChfh7NyfUlYuXSj0Dsx+XnrX9S8N8njjVYe8/5nVwKXxVfmzbL8vHW3gnTCRym6ZZblrALGQsyyQQVMg1JfETbOZfk8zqVeDqS0ebklr2onFq9Q1eF4RCWqKqKxWGVQqUBVuCpcHYgmE9UVKloRhTxjVYEo/LtAVUwlnKpwoj57p+VMvdPX+YyEv2bonb7xee+k7f6GqXeiHtotM1ypGqybL6WPviWu+G7g1/m2zlv3og5cywjL4Tu6cqjA5fBdPv/5iBVk3FWEk+f3iKeqCCeqqpPRUCIInYITDzmJYDDoBAKhZCAeSERVOBRNJpPRpEpGEjFVHQtD9pFgLAYdQ2VFZZyzXi0lrFc/0NUr1rMrP2bPM5iqsO0Pr0DT0O+R/AOSf8xfd3/4J3j/M+AXwK/5a/VFeTVnr1Iv6r6GawBHzfMnQp7FiOdvppBXmtffzesf5nVVfs35I339Ce//0j4E/K0/A0GwASAfUAAoBBQBigElgFJAQ0AZoBGgMaAJoCmgGaA5oAWgJWAjwMaATQCbAjYDbA7YArAlYCvA1oBtAK0A2wLKAa0B2wG2Tz2gtyq/ZoO5vkaZK5lGmTsUMBLWmVPnu2OBv0eZ2u4dC2oKmChfpz4r2+9MlW2nAkbCOzFUtjY+r2za7jbCK9sfTJVt5wJGwjszVLZdfF7ZtN27MFQ2Dq46ArcpoB/r7logs5GtYmpkbQsYCbdlaGS7+byRabt3E9LIdDDYlaGR7V5Aa/eGGpVXnntkzzOUqrBNfFeiCe7vSF6FZM0BT3z3hPcOQAECBesfjKbeQSHsvdWehG0zWEAb8FJ9Eyyo8YGDZIXkQIpvQvC+AhAGRArWzY+yXur4sTtDu4zSlanKz1v3oo5NvxF2eO4iRSXYvxdgb0A7wD6A9oB9dbkA9gPsDzgA0BFwIKAT4CBAZ8DBgC6AQwBdAd0A3QE9AD0BhwIOA/QC9Ab0AfQF9AMcDugPOAJwJGAA4CjA0YBjAAML1i5s4XWKSlMHsG4vi25vi66dRbePRdfeotvXoutg0e1n0e1v0R1g0XW06A606DpZdAdZdJ0tuoMtui4W3SEWXVeLrptF192i62HR9bToDrXoDrPoell0vS26PhZdX4uun0V3uEXX36I7wqI70qIbYNEdZdEdbdEdY9ENLKiJMe7lxt8O5tXxdq0Tc7zG2soC73klkmuvvQroeE1swjM2S/WFR5vje9OVX2U7urzUPoS+OFmELxKqPVn5xdS+ZHlFVQdCX0wS4QtH7UdVfglH7U+VV8xRBxD64hQJvog6qiNV+UHfcyBRXgnIqxOhLyYL8EUMbD6IqPyikFdnorzAZHUwoS9O9b8vEtrmLjTlF9N5HUKTV1Tn1ZXQF1P87wudtepGUn6JNXl1J8krtiavHoS+OM33voiusbknSfmtoakOpcgrsTavwwh9MdXvvoittbkXRflF1+bVmyKvtSarPoS+mOZzX8SNzX0JbK42efUjyCti8jqc0Ben+9sX/3wLor93m5Wb1xGe84om3byOJPTFGb72RbTatXmA9/JzbVZHec4r8k9eRxP64kxf+6LiH5uP8Wyz+ievgQV0a5Z4Pc+rL86qJ1843i5FuG6mCNd91CmEvpguxBeE6wOKcH6rphD64mwhviCcBynCcbyaRuiLc4T4gnC8pwjHK+pMQl+cK8QXhP2aIozL6mxCX5zH5IsCYl8Qtl9FWP8UV/nlp5SfH/aV3byqCMehOg/qM0D6vFW0gP4cVHUBra+p7dZfpqpksHtGE3/bretjNYPdN9VTbPTKM0bYHgl9rW7yeb3R7aWKod7c6nO7K5nay21C2kucsL0Q+lpxlR+1nxPZl18gVaG5pZ6x1vHMPUsdL7A/5D1RsO4Z6yS8PxYwCDC4YMNnrB1vl9JfVt6Loe3cyRwzvPLTNicZ7L5LyFwwSTh+Po4w/hDWGyXFF7oNUvliSAFPG/ZTu7DF2ONQXB2SZowdCu+HAYYDRjDGWP0wiL0ZYs29Po+x2uahDHbfJ6RdDyVsiyMJYyxhvVFSfLGaMMYeX8DThv3ULmwxdiSKq8enGWNHwfvRgDGAsYwxVj9spx1DrJnt8xirbR7FYPccIe16FGFbHEcYYwnrjZLii78JY+wJBTxt2E/twhZjx6G4ekKaMXY8vJ8AOBFwEmOM1QtX+zDEmgd8HmO1zeMZ7H5QSLseT/m9S8IYS1hvlBRf5FF+77KApw37qV3YYuxEFFdPTjPGToL3pwAmA05ljLH6YZHtGWLNPJ/HWG3zJAa7HxHSridRfieLMMYS1hslxRcNKL+TVcDThv3ULmwxdgqKq6elGWOnwvtpgNMBZzDGWP0w3n0ZYs3jPo+x2uapDHY/IaRdT6X8vgZhjCWsN0qKL/IJfXFWAU8b9lO7sMXYM1FcPSvNGDsd3p8NOAdwLmOM1Q8778AQa572eYzVNk9nsPsZIe16OmFbPI8wxhLWGyXFFwWEvji/gKcN+6ld2GLseSiunp9mjL0A3l8IuAhwMWOM1T8msR9DrHne5zFW23wBg90vCGnXFxC2xUsIYyxhvVFSfFFI6ItLC3jasJ/ahS3GXoLi6qVpxtjL4P3lgCsAVzLGWP1jPfszxJqXfB5jtc2XMdi9QEi7voywLV5FGGMJ642S4osiQl9cXcDThv3ULmwx9ioUV69OM8ZeA++vBVwHuJ4xxuofQzuAIda86vMYq22+hsHu14S062sI2+INhDGWsN4oKb4oJvTFjQU8bdhP7cIWY29AcfXGNGPsDHh/E+BmwC2MMVb/2GRHhlizyOcxVts8g8HuN4S06xmEbfFWwhhLWG+UFF+UEPritgKeNuyndmGLsbeiuHpbmjH2dnh/B+BOwF2MMVb/mO+BDLHmbZ/HWG3z7Qx2vyOkXd9O2BbvJoyxhPVGSfFFKaEv7ingacN+ahe2GHs3iqv3pBlj74X39wFmAmYxxlj9Y+mdGGLNez6Psdrmexnsfl9Iu76XsC3OJoyxhPVGSfFFQ0JfzCngacN+ahe2GDsbxdU5acbYufD+fsADgAcZY2xZQc1vC+J8vZbpRz6PsdrmuQx2fyykXc8lbIsPEcZYwnqjpPiijNAXDxfwtGE/tQtbjH0IxdWH04yx8+D9I4BHAY8xxthGBTW/1Yrz9Vqmn/k8xmqb5zHY/bmQdj2PsC0+ThhjCeuNkuKLRoS+eKKApw37qV3YYuzjKK4+kWaMfRLePwV4GvAMY4xtXFDz29c4X69l+oXPY6y2+UkGu78U0q6fJGyLzxLGWMJ6o6T4ojGhL54r4GnDfmoXthj7LIqrz6UZY5+H9y8AXgTMZ4yxTSDvLgyxZrnPY6y2+XkGu78W0q6fpzxHSRhjCeuNkuKLJoS+WFDA04b91C5sMfYlFFcXpBljX4b3rwBeBbzGGGObQt6HMMSa73weY7XNLzPYvUJIu36ZsC2+ThhjCeuNkuKLpoS+WFjA04b91C5sMfZ1FFcXphljF8H7NwBvAt5ijLHNIO+uDLHmR5/HWG3zIga7fxLSrhdRnvEhjLGE9UZJ8UUzQl+8U8DThv3ULmwx9m0UV99JM8YuhvfvAt4DvM8YY5tD3t0YYs2vPo+x2ubFDHb/JqRdLyZsix8QxljCeqOk+KI5oS8+LOBpw35qF7YY+wGKqx+mGWM/gvcfAz4BfMoYY1tA3t0ZYs0fPo+x2uaPGOxeJaRdf0S5/0wYYwnrjZLiixaEvvi8gKcN+6ld2GLsZyiufp5mjF0C75cCvgB8yRhjW0LePRhizWqfx1ht8xIGu/8W0q6XELbFrwhjLGG9UVJ80ZLQF8sKeNqwn9qFLcZ+heLqsjRj7HJ4/zXgG8C3jDF2I8i7J0OsyW/q7xirbV7OYHdBUxntejnl3ghhjCWsN0qKLzYi9MWKAp427Kd2YYux36G4uiLNGPs9vP8B8CPgJ8YYuzHkfShDrCn2eYzVNn/PYHeJkHb9PWFb/JkwxhLWGyXFFxsT+uKXAp427Kd2YYuxP6O4+kuaMfZXeP8bYCXgd8YYuwnkfRhDrCnzeYzVNv/KYHcjIe36V8p1O8IYS1hvlBRfbELoi1UFPG3YT+3CFmP/QHF1VZox9k94/5fWAf5mjLGbQt69GGJNU5/HWG3znwx2NxPSrv8kbIuaHBUvwnqjpPhiU0JfNCjkacN+ahe2GKvfuLG0QWF6MTYfhAJAIaCokC/Gbgb/tzdDrGnp8xirbdZlTJ3vRkLadT5hWywmjLGE9UZJ8cVmhDG2pJCnDfupXdhibDGKqyVpxthSEBoCygCNGGPs5vB/+zDE2E19HmO1zaUMMXYzIe26lLAtNiaMsYT1RknxxeaEMbZJIU8b9lO7sMXYxiiuNkkzxjYFoRmgOaAFY4zdAv5vX4YYu6XPY6y2uSlDjN1KSLtuSjneIYyxhPVGSfHFFoQxdqNCnjbsp3Zhi7EtUVzdKM0YuzEImwA2BWzGGGO3hP/bjyHGtvJ5jNU2b8wQY7eVspdN2BY3J4yxhPVGSfHFloQxdotCnjbsp3Zhi7Gbo7i6RZoxdksQtgJsDdiGMcZuBf/3cIYYu53PY6y2eUuGGLu9lHZN2RYJYyxhvVFSfLEVYYzdtpCnDfupXdhibCsUV7dNM8aWg9AasB1ge8YYuzX83/4MMXYnn8dYbXM5Q4xtI6RdlxO2xR0IYyxhvVFSfLE1YYzdsZCnDfupXdhi7A4oru6YZozdCYQ2gJ0BuzDG2G3g/x7BEGN39XmM1TbvxBBj2wpp1zsRtsVdCWMsYb1RUnyxDWGMbVvI04b91C5sMXZXFFfbphljdwNhd8AegD0ZY2wr+L9HMsTYPXweY7XNuzHE2D2FtOvdCNuiQxhjCeuNkuKLVoQxVhXytGE/tQtbjHVQXFVpxtgACEFACFDBGGO3hf87gCHGBnweY7XNAYYYGxTSrgOEbTFMGGMJ642S4ottCWNspJCnDfupXdhibBjF1UiaMTYKQiVgL8DejDG2HP7vUQwxNuzzGKttjjLE2IiQdh0lbIvtCGMsYb1RUnxRThhj9ynkacN+ahe2GNsOxdV90oyx7UHYV5cXYD/GGNsa/u/RDDF2L5/HWG1ze4YYu7eQdt2esC3uTxhjCeuNkuKL1oQx9oBCnjbsp3Zhi7H7o7h6QJoxtiMIBwI6AQ5ijLHbwf89hiHGtvd5jNU2d2SIsfsKadcdCdtiZ8IYS1hvlBRfbEcYYw8u5GnDfmoXthjbGcXVg9OMsV1AOATQFdCNMcZuD/93IEOM3d/nMVbb3IUhxh4gpF13IWyL3QljLGG9UVJ8sT1hjO1RyNOG/dQubDG2O4qrPdKMsT1BOBRwGKAXirHulU/s5xZ5dOXZs5Cnbhek2OyV50/5dOW3Mp+OV2/C8iuCPBrl1fQl+KLuryl5Y759ChkJ9ymkz7cvYaDjsrsviihE+a6pbPl5NcGJs7IRNl6Hk+fKfJ5G0Q/VW/onDRCOmjS3AsPRJV2EdNwVhdIBuGIfbhpQf20ThwP6MUSmfsRdM5fd+Yx2ez72zVyGjrdL6Yp5BMP08Uji7t0NADrfySZf6rLoz1QWA5jKYgBjWehAyFEWnfz+dWOmOnDQv2t3rA5+bHW/M9PSRer0zvF2KcJ6qQh9rSjLTw+k9DjENuLOy7A866pPOE+OPouqTPCg8qjaRsmOt0sdwdQJYNIZclZ1/R/N+SiGoNDVJ+uZmQzePJ83KfRngOnalKdeHo0GJ9n6p64yp/TPMSgvFQxC24hHVDKeDFZEKgPVKhwMh5OhZCQcDcWTFaGqeCShQlXBQGUi4iRVNJGIVARjkXCyMh4LJ3HQVvFgMBSvrI6pikC4qtqJxoNVTjIUCQacqngwEo8Ho+FwVTAYD0eT0cpoIFCVDEadikik0gkHgpUBLv8cY/xTn7NrymUY3IkNNBWrSkoA5+I3kCFYVzN1XNWMsxddFlUMZRFjKosYY1n8xDST6+73L9wztYcePp/JcdX9nkJmcoT1UhH6WvXMzeRSLzWQaSYXlziTizPP5OIMQaH3f3Amlyj0Z4DpzTRTSAibySUJZ3I9CWdyXP5JopnchjoFPy/BcfLk6mCOldjBHMvcwRzL0MH0racOhnKf10d7Ret0MJ4fd15PMwCvPAcRdtCE9U/1Y+oABqXRQXst08GFdB3hOsujPuqg+zL5Z/D/0VLrcaZiDbEdZHK8XWpDB3ooT6h5DoKEwYXD8W4ZUgdVrjL0mtdQn/tDN5ihDAOjYUyDxGGMS9FDmMpiOFNZDGdelucoiyN8vizP1R6O9PmyPFfdHyBkWZ6wXipCX6sBuWX51GtNn0VVJniwO4Jz1WQoUycwgnHVRHMewRAUBgpZlh9KOBAcWejPADOQaVY5sh6W5Sn9czzhsvwAwlk/l3+O/xdm/VxfXxplKtZoKQGci98ohmA9hqnjGsM4e9FlMZqhLMYylcXYQt6vynCM7Kt9PpPjag8xn8/kuOp+XMhMjrBeKkJfq3huJpd6qVFMM7lxEmdy45hncuMYgsKg/+BM7oRCfwaYQUwzhROEzeTGE87k4oQzOS7/jP8XDlhRLsFx8uTqYCZI7GAmMHcwExg6mOOEHLCiDGBHMo1gvfIaIuSA1YmEHTRh/VNDmDqAE+vhgNVJhAesBjT1Zwd9HJN/TrL4h3rWiw9UefX1H4R5TSTsy+rz+X8TmQYOJxcyEj65kD7fSYQdG5fdkwprCpgo33p9/h9ucI7Hi5Mn5alN3ChOqW007bXSTSIcDeCo7pL+fzg2O9k0oFNtx2YpHHAKQ2Q6hXlDjsrufEa7vXKc4vNNTV0xpzBMK09jmmKfxriRdypTWUxlKoupzMdTOcpiuM83Nbnawwifb2py1f2RQjY1CeulIvS1Gpnb1Ey91vRZVGWCB5XTONecpzB1AtMY15w152kcJ56EbGpOIRwInl7ozwAzhmlN7vR62NSk9M8ZhJuaIwnXTLn8c8a/cDyVchkGd2Jnmop1lpQAzsXvTIZgPZ2p45rOOHvRZXEWQ1mczVQWZzOWxR9MM7lxPp/JcbWHE3w+k+Oq++OFzOQI66Ui9LUan5vJpV7qTKaZ3DkSZ3LnMM/kzmEIChP/gzO5cwv9GWAmMs0UzhU2kzuPcCY3nnAmx+Wf8/6F46mUS3CcPLk6mPMldjDnM3cw5zN0MJOEHE+lDGAjmEawXnmdIuR46gWEHTRh/VOnMHUAF9TD8dQLCY+njmzqzw56EpN/Lvw/Wmq9yFSsi20HmRxvl9rQgR7KE2qegyBhcOFwvFuG1EGVqwy95nWJz/2hG8wlDAOjS5kGiZcyLkVfzFQWlzGVxWXMy/IcZTHF58vyXO3hNJ8vy3PV/alCluUJ66Ui9LWamluWT73W9FlUZYIHu5dzrppcwtQJXM64aqI5X84QFM4Usix/CeFA8IpCfwaYM5lmlVfUw7I8pX+uJFyWn0o46+fyz5X/wqyf6+tLV5mKdbWUAM7F7yqGYH0NU8d1DePsRZfF1QxlcS1TWVxbyPtVGY6R/XSfz+S42sPZPp/JcdX9c4TM5AjrpSL0tTonN5NLvdRVTDO56yTO5K5jnsldxxAULvgPzuSuL/RngLmAaaZwvbCZ3A2EM7lzCGdyXP654V84YEW5BMfJk6uDuVFiB3MjcwdzI0MHc5GQA1aUAew0phGsV14XCzlgNYOwgyasf+pipg5gRj0csLqJ8IDV1Kb+7KAvYvLPTbWs7lCce7mkkP4hQ5Tx7Gafr5zuAo7arYDeN7cw203xm6lDGeoO5bNwb/V5Geq6fUsh/SoWYZtRtxD64zaf+0PXl9sYxqG3M5/j88pPr/LfznF2ram/Y/dKJrsvZxrrUsdaQv+oy32+o/M7k6/vIIxp9fmMYkremO+dhYyE7yykz/cuwg6Oy+67CmsKmCjfNZXNfU4xd2Vrk8cTEKl5LiM8Y9IY8bzb+O8e83qveb3PvM40r7PM62zzOse8zjWv95vXB8zrg7WtJHqtzHcRjlrwjPZeQxrrZll0cy061+D6jJR3M0XKhwoZCT/EECkf9nmk1HY/zBQp66uy3cNU2eYVMhKex1DZHvF5ZdN2P8JQ2Wxcvdp/r2kY1PMHyoDwqNBx9H1MDfaxQkbCjzE02Md93mC13Y8L7x1mMlW2JwoZCT/BUNme9Hll03Y/KaR3mGUaBnXvQBkQnvL5LpAeCTzKsLr0tM/t1nX8KQa7nxE6GpjNFKCfLWQk/CxDgH7O5wFa2/2c8NHAHKbK9nwhI+HnGSrbCz6vbNruF4SMBuaahkE9GqAMCC/6vFfUvfYzDL3ifJ/brev4iwx2vyR0NHA/U4BeUMhIeAFDgH7Z5wFa2/2y8NHAA0yV7ZVCRsKvMFS2V31e2bTdrwoZDTxoGgb1aIAyILzm815R99ovMfSKr/vcbl3HX2OweyGx3e6VT8yT8mDJIuYThI63S+m6uJDB128w+Zqa55tkPIMhTp5vZc8znqrQ3DbLq/m2iH6vy2G1ke9G8j1IfsvI7n1vg/AOYDHg3cIavXtRn46+l7AtvU3Yxt9jquvU5Ue446neISy/94WUH+EmnlpMWH4fEE8gUmPDeygGvI/kD5D8bkps+BCEjwAfAz6ph9gwi9A3HxL65lMhdZtw/0N9RFh+nwkpP8IlffUxYfl9zhwbPkUx4DMkf47kT1JiwxIQlgK+AHxZD7FhLqFvlhD65ishdZtwNVQtJSy/ZULKj3CBT31BWH7LmWPDVygGLEPyciR/mRIbvgbhG8C3gO/qITY8SOibrwl9s4LZNyuQD75B8rdI/i7FN9+D8APgR8BPhevmh31CsWbyBsPa5SJC//zs8zU87aufGdZ1fvG53VzfFvzV53bruv0Lg91X+fzbodruXxnsvlrIN4EJ/aOuJn5WZXFe/WygUn5JsQni+Zvp4Faa19/N6x/mdZV5/dO8/mVeV5vXv90OssjYbV7zzWtBUS1fAnS8XYrwS4DrPNbm98L1v9z3p0X3t0WXX1T/XwL8jbgc3KuwiJFwYRF9vkVF/t5d13YXFdUUMFG+9XqUYyVTZSsuYiRczFDZSnxe2bTdJQyVzcbV8wMwTMOgHjpQBoTSIpkN9g+mBtuwiJFwQ4YGW+bzBqvtLhPeO6xiqmyNihgJN2KobI19Xtm03Y2F9A5/moZB3TtQBoQmRbxl6Hi71oxWSovofdPU53brOt6Ewe5mQkcDfzEF6OZFjISbMwToFj4P0NruFsJHA6uZKlvLIkbCLRkq20Y+r2za7o2EjAb+Ng2DejRAGRA29nmvqHvtZgy94iY+t1vX8Y0Z7N5U6Gggr4gnQG9WxEh4M4YAvbnPA7S2e3Pho4EGTJVtiyJGwlswVLYtfV7ZtN1bChkN5JuGQT0aoAwIW/m8V9S99qYMveLWPrdb1/GtGOzexud2a79sw2B3K+IAX9sXuH5D8srCDX+Ba1vgVA5oDdiuiP+w5e+Ehy23JYxB2xPXSa7yI9ytUuWE5beDkPIj3IBRrQnLb0fm2KDrtxsDdkDyjkjermjd2LATvG8D2BmwSz3Ehj8JfbMToW92FVK3CdeuVRvC8msrpPwIl2PVzoTltxtzbNgVxYC2SN4NybukxIbd4f0egD0BTj3Ehr8JfbM7oW+UkLpNuJKl9iAsv4CQ8iNcnFF7EpZfkDk2KBQDAkgOItlJiQ0heF8BCAMi9RAb8gl9EyL0TZTZN1Hkgwokh5EcSfFNJbzfC7A3oF0R3xe49NnzVgzrTpQP5tmHKfZQl2V7Op5JGz/H26V0ndqHYb1kX+b20x61k32RXIDkH/PXbT8dIG0/wP6AA2ppP463a80XWu5i+FLTdT7/Mtea9s1Ql64X8mUuQv+o633+E57a178z1PEZPrdbP8RqEYPdNzHV8QJinh0Jx2uEvlY3Mf0MfEcUzzja0J8MdelWn7ehWUxt6DYhbehAwjZE6Gt1G3EbaphX08fq90vya8ZmO+etlfXVqShvnYu6X+5EOC88iM53Mdu4dgUqo++RfFAt49rOkHYwoAvgEDOuLTKfzc9b/6Juz5S/3srJszPhnKQY8exq6m8389rdvPYwrz2Lauq8vg6F94cBegF6A/oA+gL6AQ4H9AccATgSMABwFOBowDGAgYAqQDUgBogDEoAk4FjAIMBgwHGAIYChgGGA4YARgJGA4wGjAKMBYwBjAeMAJwDGuxXH7QA1+fK8+v3SdzfiyaN7TShiJDyhiD7fEwkjF5fdJ6LoTZRvvR7d685U2U4qYiR8EkNlm+jzyqbtnii8svVgqmwnFzESPpmhsk3yeWXTdk9iqGwcXE80DYN6PnVKkcxG1pOpkU0uYiQ8maGRnerzRqbtPlVII9PB4BSGRjaFeaOkG5o4dkdyTyTvUbDuhPI0SJsKmAY4vYh/E5iwV1SnEdb5M5h9cwbywVQkT0Py6UXr+uZMeH8WYDrg7CK+TWDdLqcw1PdzCH2durhB3ea7EvrfnfyfC3meBzgfcAHgQsBFgIsBlwAuBVwGuBxwBeBKwFWAqwHXAK4FXAe4HnAD4EbADMBNgJsBtwBuBdwGuB1wB+BOwF2AuwH3AO4F3AeYCZgFmA2YA5hbtHbBCM//zzV1AOvOs+jOt+gusOgutOgusugutugusegutegus+gut+iusOiutOiusuiutuiuseiuteius+iut+husOhutOhmWHQ3WXQ3W3S3WHS3WnS3WXS3W3R3WHR3WnR3WXR3W3T3WHT3WnT3WXQzLbpZFt1si26ORTcXxUP3+udwgXl1vF3rxByvsfZcgrwSybXXeYS87mTaqEn1hUeb4+fTlV/lBXR5qQsJfXGXCF8k1EVk5RdTF5PlFVWXEPribhG+cNSlVOWXcNRlVHnFHHU5oS/ukeCLqKOuoCo/6HuuJMoroZ9sTeiLewX4IqafwE1UflHI6xqivMBkdS2hL+7zvy8S2ubraMovpvO6niavqM7rBkJfzPS/L3TW6kaS8kusyWsGSV6xNXndROiLWb73RXSNzTeTlN8amuoWirwSa/O6ldAXs/3ui9ham2+jKL/o2rxup8hrrcnqDkJfzPG5L8zP66o7CWyuNnndRZBXxOR1N6Ev5vrbFwHDU93j3Wbl5nWv57yiSTev+wh9cb+vfRGtdm2e6b38XJvVLM95Rf7JazahLx7wtS8q/rF5jmeb1T95zSXch8HreV598WA9+cLxdinCdTNFuO6j7iH0xUNCfEG4PqAI57dqJqEvHhbiC8J5kCIcx6s5hL6YJ8QXhOM9RTheUQ8Q+uIRIb4g7NcUYVxWDxP64tF6+gKW4+1ShO1XEdY/xVV++Snl54d95X/mQYTjUJ0H9Rkgfd7qHIZzUA8U0fqa2m79JaVzGex+3edfTtX18QEGuxcK+XLqg4TtkdDXaqHP641uL/cz1Js3fW73uUzt5S0h7eUhwvZC6GtFWX7at6lnl3WccM8oP4Tk+fk1ciLlXPnD8Ll5gEcAjxbxPYBHf7n2PIY6udjnD+DRNj/MYPe7QuZYDxOOSx8jbNeE9UZJ8cVhhL54vIinDfupXdhi7GMorj6eZox9Aj73JOApwNOMMVY/vOB8hljzgc9jrLb5CQa7PxTSrp8gbIvPEMZYwnqjpPiiF6Evni3iacN+ahe2GPsMiqvPphljn4PPPQ94AfAiY4zVD4e5gCHWfOLzGKttfo7B7k+FtOvnCNvifMIYS1hvlBRf9Cb0xUtFPG3YT+3CFmPno7j6UpoxdgF87mXAK4BXGWOsfvjWhQyxZonPY6y2eQGD3UuFtOsFhG3xNcIYS1hvlBRf9CH0xetFPG3YT+3CFmNfQ3H19TRj7EL43CLAG4A3GWOsfrjhRQyx5iufx1ht80IGu5cJadcLCdviW4QxlrDeKCm+6Evoi7eLeNqwn9qFLca+heLq22nG2Hfgc4sB7wLeY4yx+uGxFzPEmm98HmO1ze8w2P2tkHb9DmFbfJ8wxhLWGyXFF/0o11CLeNqwn9qFLca+j+LqB2nG2A/hcx8BPgZ8whhj9cO5L2GINd/7PMZqmz9ksPsHIe36Q8K2+ClhjCWsN0qKLw4n9MVnRTxt2E/twhZjP0Vx9bM0Y+zn8LklgKWALxhjrP7xg0sZYs3PPo+x2ubPGez+RUi7/pywLX5JGGMJ642S4ov+lPP7Ip427Kd2YYuxX6K4+lWaMXYZfG454GvAN4wxVv+4zGUMsWalz2OstnkZg92/C2nXywjb4reEMZaw3igpvjiC0BffFfG0YT+1C1uM/RbF1e/SjLEr4HPfA34A/MgYY/WPd13OEGv+9HmM1TavYLD7LyHtegVhW/yJMMYS1hslxRdHUo49i3jasJ/ahS3G/oTi6s9pxthf4HO/An4DrGSMsfrHEa9giDV5zfwdY7XNvzDY3aCZjHb9C2Fb/J0wxhLWGyXFFwMIffFHEU8b9lO7sMXY31Fc/SPNGLsKPvcn4C/9ecYYq3989kqGWFPo8xirbV7FYHeRkHa9irAt/k0YYwnrjZLii6Mo42IxTxv2U7uwxdi/UVzVZZBOjG0An8sHFAAKi/lirP5x76sYYk2pz2PsGpuL6fNtKKRdNyBsi0XFdLwI642S4oujCWNscTFPG/ZTu7DF2CIUV4vTjLEl8LlSQENAGWOMPaao5jf7cL5ey7Sxz2OstrmEIcY2EdKuSwjbYiPCGEtYb5QUXxxDGGMbF/O0YT+1C1uMbYTiauM0Y2wT+FxTQDNAc8YYO7Co5jdQcb5ey7S5z2OstrkJQ4xtIaRdNyFsiy0IYyxhvVFSfDGQMMa2LOZpw35qF7YY2wLF1ZZpxtiN4HMbAzYBbMoYY6uKan5TGufrtUw39nmM1TZvxBBjNxHSrjcibIubEcZYwnqjpPiiijDGbl7M04b91C5sMXYzFFc3TzPGbgGf2xKwFWBrxhhbDf69jiHGbu7zGKtt3oIhxm4hpF1vQdgWtyGMsYT1RknxRTVhjG1VzNOG/dQubDF2GxRXW6UZY7eFz5UDWgO2Y4yxMfDv9Qwxdmufx1ht87YMMXYbIe16W8K2uD1hjCWsN0qKL2KEMXaHYp427Kd2YYux26O4ukOaMXZH+NxOgDaAnRljbBz8ewNDjC33eYzVNu/IEGNbC2nXOxK2xV0IYyxhvVFSfBEnjLG7FvO0YT+1C1uM3QXF1V3TjLFt4XO7AXYH7MEYYxPg3xsZYuwOPo+x2ua2DDF2RyHtui1hW9yTMMYS1hslxRcJwhjrFPO0YT+1C1uM3RPFVSfNGKvgcwFAEBBijLFJ8O8Mhhi7s89jrLZZMcTYXYS0a0XYFisIYyxhvVFSfJEkjLHhYp427Kd2YYuxFSiuhtOMsRH4XBRQCdiLMcYeC/69iSHG7ubzGKttjjDE2N2FtOsIYVvcmzDGEtYbJcUXxxLG2HbFPG3YT+3CFmP3RnG1XZoxdh/4XHvAvrrMGGPsIPDvzQwx1vF5jNU278MQY5WQdr0PYVvcjzDGEtYbJcUXgwhj7P7FPG3YT+3CFmP3Q3F1/zRj7AHwuY6AAwGdGGPsYPDvLQwxNuTzGKttPoAhxlYIadcHELbFgwhjLGG9UVJ8MZgwxnYu5mnDfmoXthh7EIqrndOMsQfD57oADgF0ZYyxx4F/b2WIsVGfx1ht88EMMbZSSLs+mLAtdiOMsYT1RknxxXGEMbZ7MU8b9lO7sMXYbiiudk8zxvaAz/UEHAo4jDHGDgH/3sYQY9v5PMZqm3swxNh9hLTrHoRtsRdhjCWsN0qKL4YQxtjexTxt2E/twhZje6G42jvNGNsHPtcX0A9wOGOMHQr+vZ0hxnbweYzVNvdhiLH7CWnXfQjbYn/CGEtYb5QUXwwljLFHFPO0YT+1C1uM7Y/i6hFpxtgj4XMDAEcBjmaMscPAv3cwxNiOPo+x2uYjGWLsgULa9ZGEbfEYwhhLWG+UFF8MI4yxA4t52rCf2oUtxh6D4urANGNsFXyuGhADxBlj7HDw750MMbazz2OstrmKIcYeLOU5JIRtMUEYYwnrjZLii+GEMTZZzNOG/dQubDE2geJqMs0Yeyx8bhBgMOA4xhg7Avx7F0OM7erzGKttPpYhxnaTciaTsC0OIYyxhPVGSfHFCMIYO7SYpw37qV3YYuwQFFeHphljh8HnhgNGAEYyxtiR4N+7GWJsT5/HWG3zMIYYe6iU+SlhWzyeMMYS1hslxRcjCWPsqGKeNuyndmGLscejuDoqzRg7Gj43BjAWMI4xxh4P/r2HIcb29nmM1TaPZoixfYS069GEbfEEwhhLWG+UFF8cTxhjxxfztGE/tQtbjD0BxdXxacbYCfC5EwEnASYyxthR4N97GWLs4T6PsdrmCQwxtr+Qdj2BsC2eTBhjCeuNkuKLUYQxdlIxTxv2U7uwxdiTUVydlGaMPQU+NxlwKmAKY4wdDf69jyHGDvB5jNU2n8IQY48S0q5PIWyLpxHGWMJ6o6T4YjRhjJ1azNOG/dQubDH2NBRXp6YZY6fB504HnAE4kzHGjgH/zmSIsQN9HmO1zdMYYmyVkHY9jbAtnkUYYwnrjZLiizGEMXZ6MU8b9lO7sMXYs1BcnZ5mjD0bPncO4FzAeYwxdiz4dxZDjI37PMZqm89miLEJIe36bMK2eD5hjCWsN0qKL8YSxtgLinnasJ/ahS3Gno/i6gVpxtgL4XMXAS4GXMIYY8eBf2czxNhBPo+x2uYLGWLsYCHt+kLCtngpYYwlrDdKii/GEcbYy4p52rCf2oUtxl6K4uplacbYy+FzVwCuBFzFGGNPAP/OYYixQ30eY7XNlzPE2GFC2vXlhG3xasIYS1hvlBRfnEAYY68p5mnDfmoXthh7NYqr16QZY6+Fz10HuB5wA2OMHQ/+ncsQY0f6PMZqm69liLHHC2nX1xK2xRsJYyxhvVFSfDGeMMbOKOZpw35qF7YYeyOKqzPSjLE3weduBtwCuBXFWPfKJ/Zzizy68rypmKduF6TY7Pm7gkV05deNsJ3cRlh+QCuvUV5NX4Iv6v6akjfme3sxI+Hbi+nzvYMw0HHZfUdxTQET5bumsuXn1QQnzspG2HgdTp7dingaxZ2o3tI/zYVw1KS5FRiOLukipOOuKJQOwBX7LtOA7tY2cTjgTobIdCdx18xldz6j3Z6/WsNcho63S+mKeQ/D9PFe4u7dDQA638kmX+qyuJupLO5jKov7GMtCB0KOshjj90c6MNWBsf+u3bE6+LHV/XFMSxep0zvH26UI66Ui9LWiLD89kNJLA7YRd16G5VlXfcJ5cvRZVGWCB5UzaxslO94udQ9TJ4BJZ8hZ1fV/NOeZDEHhRJ+sZ2YyePN8pq/YnwHmxGY89XIWGpxk65+6ypzSP7NRXioYhLYRj6hkPBmsiFQGqlU4GA4nQ8lIOBqKJytCVfFIQoWqgoHKRMRJqmgiEakIxiLhZGU8Fk7ioK3iwWAoXlkdUxWBcFW1E40Hq5xkKBIMOFXxYCQeD0bD4apgMB6OJqOV0UCgKhmMOhWRSKUTDgQrA1z+mW38U5+z685Ms+s5ZnY9V0oA5+I3hyFY38/Ucd3POHvRZTGXoSweYCqLBxjLojPTTG6i3x9qwtQeTvb5TI6r7k8SMpMjrJeK0NdqUm4ml3qpOUwzuQclzuQeZJ7JPcgQFKb8B2dyDxX7M8BMYZopPCRsJvcw4UxuEuFMjss/D6OZ3IY6BT8vwXHy5Opg5knsYOYxdzDzGDqYqfXUwVDu8/por2idDsYrr2n1NAPwyvMRwg6asP6paUwdwCNpdNBey/TRYrqOcJ3lUR910FOZ/PPo/9FS62NmqfVx20Emx9ulNnSgh/KEmuff1SEMLhyOd8uQOqhylaHXvJ7wuT90g3mCYWD0JNMg8UnGpejHmcriKaayeIp5WZ6jLM70+bI8V3s4y+fL8lx1f7qQZXnCeqkIfa2m55blU681fRZVmeDB7tOcqyZPMHUCTzOummjOTzMEhfOELMs/QTgQfKbYnwHmPKZZ5TP1sCxP6Z9nCZflpxPO+rn88+y/MOvn+vrSc2bW/7yUAM7F7zmGYP0CU8f1AuPsRZfF8wxl8SJTWbzI/FUZjpH9BT6fyXG1hwt9PpPjqvsXCZnJEdZLRehrdVFuJpd6qeeYZnLzJc7k5jPP5OYzBIXL/oMzuZeK/RlgLmOaKbwkbCa3gHAmdxHhTI7LPwv+hQNWjxXztHspHczLEjuYl5k7mJcZOpgrhBywogxgZzGNYL3yulLIAatXCDtowvqnrmTqAF6phwNWrxIesJrezJ8d9BVM/nnV4h/qWW9nwmf29SDM6zXCvqw+n//3GtPA4fViRsKvF9Pnu5CwY+Oye2FxTQET5Vuvz//rIeT5f52Znv+3qLbRtNdKt5BwNICjukv6/+HY7BumAb1pOzZL4YBFDJFpEfOGHJXd+Yx2e+X4ls83NXXFfIthWvk20xT7bcaNvDeZyuIdprJ4h/l4KkdZXOPzTU2u9nCtzzc1uer+dUI2NQnrpSL0tbout6mZeq3ps6jKBA8qF3OuOb/F1AksZlxz1pwXMwSFGUI2Nd8iHAi+W+zPADODaU3u3XrY1KT0z3uEm5rXEa6ZcvnnvX/heGoPptn1+2Z2/YGUAM7F732GYP0hU8f1IePsRZfFBwxl8RFTWXzEWBY9mGZyN/t8JsfVHm7x+UyOq+7fKmQmR1gvFaGv1a25mVzqpd5nmsl9LHEm9zHzTO5jhqBw539wJvdJsT8DzJ1MM4VPhM3kPiWcyd1KOJPj8s+n/8Lx1DeKedq9lA7mM4kdzGfMHcxnDB3M3UKOp1IGsGuZRrCen3Eo5Hjq54QdNGH9U/cwdQCf18Px1CWEx1Ova+bPDvpuJv8s+T9aal1qllq/sB1kcrxdakMHeihPqHnNi/BQFMvz5twypA6qXGXoNa8vfe4P3WC+ZBgYfcU0SPyKcSn6C6ayWMZUFsuYl+U5ymKmz5fludrDLJ8vy3PV/dlCluUJ66Ui9LWanVuWT73W9FlUZYIHu8s5V02+ZOoEljOummjOyxmCwgNCluW/JBwIfl3szwDzANOs8ut6WJan9M83hMvyswln/Vz++eZfmPVzfX3pWzPr/05KAOfi9y1DsF7B1HGtYJy96LL4jqEsvmcqi++ZvyrDMbJ/yOczOa728LDPZ3JcdX+ekJkcYb1UhL5W83IzudRLfcs0k/tB4kzuB+aZ3A8MQeHx/+BM7sdifwaYx5lmCj8Km8n9RDiTm0c4k+Pyz0//wgGrpcU87Z6aJ1cH87PEDuZn5g7mZ4YO5kkhB6woA9gsphGs598xE3LA6hfCDpqw/qmnmDqAX+rhgNWvhAesZjfzZwf9JJN/fq1ldYfi3MuXxfQPGaKMZ7/5fOV0EoycTi2i981KZrspfjP1CYa6Q/ks3N99Xoa6bq8spl/FImwzaiWhP/7wuT90ffmDYRy6ivkcn1d+epV/FYPdzzbzd+zuxmT3c0xjXepYS+gf9ZzPd3S6M/n6T8KYVp/PKP6TaXHjr2JGwn8V0+e7mrCD47J7dXFNARPlu6ayuc8p5q5sO+fxBERqnsvy6Xg2Rjz/dv1XYnib13zzWmBeC81rkXktNq8l5rXUvDY0r2Ultawkeq3MqwlHLXhG28CQxrpCi67EonMNrs9I+TdTpGxUwki4UQl9vo1L/B0ptd2NS2oKmCjfeu2W80p4KluTEkbCTRgqW1OfVzZtd1OGymbj6tV+HXF1w6CeP1AGhGYlMhtsPlODbV7CSLg5Q4Nt4fMGq+1uIbx3KGCqbC1LGAm3ZKhsG/m8smm7NxLSOxSahkHdO1AGhI1LeMvQ8XatGa00K6H3zSY+t1vX8Y0Z7N5U6GigiClAb1bCSHgzhgC9uc8DtLZ7c+GjgWKmyrZFCSPhLRgq25Y+r2za7i2FjAZKTMOgHg1QBoStfN4r6l57U4ZecWuf263r+FYMdm8jdDRQyhSgW5UwEm7FEKC39XmA1nZvK3w00JCpspWXMBIuZ6hsrX1e2bTdrYWMBspMw6AeDVAGhO183ivqXnsbhl5xe5/brev4dgx270Bst3vlE/OkPFiyI53NLE8C1HVxBwZf70TcqW2WV/PtBv3+TXiz2sh6+9iV9e6eK79lPuPe1wbSdgbsAti1pEbvXtSneRsQ+r4NYdxty9QOqcuPcIdO7UxYfrsJKT/CTSe1C2H57c4cG9qiGLAbkndH8q4l68aGPeD9ngAHoOohNhQS+mYPQt8EhNRtwvV6tSdh+QWFlB/hErRyCMsvxBwbAigGBJEcQrJKiQ0V8D4MiACi9RAbSgh9U0Hom0ohdZtw9U6FCctvLyHlR7ggpSKE5bc3c2yoRDFgLyTvjeRoSmxoB+/3AbQH7FsPsaGM0DftCH3Tgdk3HZAP9kFyeyTvm+Kb/eD9/oADAB1L1s0P+4Rijr8Tw1rbjoT+OdDna07aVwcyrEN08rndXN9uO8jnduu63YnB3y/6/NuM2u6DGOyeL+Sbq4T+UfOJn61YnFc/G36UX6prgnh2NntTB5vXLub1EPPa1bx2M6/dzWsP89rTvB5qXg8zr73Ma++SWr605ni71GriL2u5XzzrUrL+l9G6WXQ9LbpeJfX/pbXOxAMp9+pTwki4D8NucF+f7wZru/uW1BQwUb71evTgYKbK1q+EkXA/hsp2uM8rm7b7cCFHD7qYhkE9dKAMCP1LZDbYQ5ga7BEljISPYGiwR/q8wWq7jxTeO3RlqmwDShgJD2CobEf5vLJpu48S0jt0Mw2DunegDAhH+3zxRI8E+jMsIhzjc7t1HT+awe6BQkcD3ZkCdFUJI+EqhgBd7fMAre2uFj4a6MFU2WIljIRjDJUt7vPKpu2OCxkN9DQNg3o0QBkQEj7vFXWvPZChV0z63G5dxxMMdh8rdDRwKFOAHlTCSHgQQ4Ae7PMAre0eLHw0cBhTZTuuhJHwcQyVbYjPK5u2e4iQ0UAv0zCoRwOUAWGoz3tF3Wsfy9ArDvO53bqOD2Wwe7jP7dZ+Gc5g9wjiAF/bF7g6l9TIB5ds+AtcIyHteMAowOgS/sOWXejKQI0kjEFjiOskV/kR7lap4wnLb6yQ8iPcgFGjCMtvHHNsGINiwFgkj0Py6JJ1Y8MJ8H48YALgxHqIDd0IfXMCoW9OElK3Cdeu1XjC8psopPwIl2PVBMLyO5k5NpyEYsBEJJ+M5BNTYsMkeH8KYDLg1HqIDT0JfTOJ0DdThNRtwpUsdQph+Z0mpPwIF2fUZMLym8ocG6agGHAakqci+dSU2DAN3p8OOANwZj3Ehl6EvplG6JuzmH1zFvLB6Ug+A8lnpvhmOrw/G3AO4NwSvi9w6bPnIxjWnSgfJHOez9chtK/OY1iHOJ+5XrYvqql/56O62BvJP+avWy8vgLQLARcBLq6lXjrerjVfFFnN8OWwl33+JSlt8wUMdekVIV+SIvSPesXnP+Wofd2Twdev+9xu/ZCHHRnsXijk59ovIRwHEfpaLWT6OfBLkK+p69Jd0AH9Vkhfl970eRu6G2xexGD3W0La0KWEbYjQ1+otn9cb3V5WMtSbxT63+x6m9vKukPZyGWF7IfS1epe4z0md41yK5jKXIblj0YbnOJfD564AXAm4ysxx9AEjdJRknYNGV5eYDxTk1c8JpMsJJ4b5iOc1xsJrS1IMoF4Jupxw9eaa9POK1ZGXupawYOuzQlzNVCGuMxXheu4KcTVhhbiOsEJcL7RCLM3nqRA3mIpwI3eFwAZ4rRA3EFaIG4nX5Bob5KWUX9AJBcKJcKgqkQg6icrKaEwFY9FYIhGLVwWrIpGoE4lXJ6riFYHqWCAZrE46iapEtEJVh6ojyomp1Sn5KbC3IlzlhKPJsBN0AsFAyIlVhqtD8aqKUCQUDkN2wepoRKlYRUDFIqFoQAWqVEV1zAmGElXh1bT+dVIrfCAaqIhFKmOxcFVFrLo6kUhG4uGqaFJVh6tUoDoIZKqCwWgo5FQlkonqULAyrELRWBQ8FIk5ocr17AXXJuNKW1cdccKBeLi6Qjs+EQxXVzqRYDhY4STDyeoqRwUC0VgITA44lZUVTmWyIuKoBLe9TiJerRKBymAsGEtUquokGJEAsaqqwokHYhUhlayqjEMFBF5grhNMJKtVLFkViFUHgxWR5Hr2BkMqHo5UJKvAu4lYIggOh9oRjFUFQ1AOwWpVWR1OVEbCAScUjoAuBMUXCMVCUMrxRLCC3d4QlHMQnAVNzYE2F49FA4loVUVFVWVFIB6KJwNOoCKcTDjQ1uKVoUpQg0+qHCfpVFUn1fr8qqK6ZMJO3IE/yYp4FJpxqDIeiiah6YTiDlQPp7oymohHVKSqsroiGKhKhoPQMiqCTqRScdhbmldzEeVLztMd816DxsLXIvk6JF+P5BuQfKORZ8DrTYCbS9YOf7X9RXnrX37u3Cx0PecdUaEA1PSIuwbG8T/MpbjKmHKKwcXx6hKeekDNc4YQnp/n08d/fd2SOlikJn4LUwHnMxaw10HtrYQLOnixXudbnle/D37jqni3lTASvq2EPt/bCafBXHbfjlozUb5su6vdGXYZP/D5SncR0+7qh0JWuu8gDIyEvlYfCjiN0IOh3nzic7uLmdrLp0Lay52E7YXQ1+pT5p2hO9CM9k4kX1LL6be7IO1uwD2Aey0nZqkHjHcRjgfuw34OO+FwZTLkwOJiUjkBR4UqK6thaaRKJSpiKlwZjYcTMfg/sWC0orIKVlfisPRWpaLVsWAFrLHU5+DwPuIVV/eaWcJIeCbD4HCWzweH2u5ZDINDXdka5tU0Ls7KdhfTTJK4TAI48Mw2ZT7HvM41r/ejOkjeu81imn7ONaRtEXs2isxzkDy3loj9AKQ9CHgI8DDjeeW7TOWnLuclPj+vrG1+gMHupUyjp0JinoQBQz1AmBdhvVFLiX9sYkPnaObV9zmaeUzHJh4xFj7KvUs+j3BI8AjhLvmjDLvkeCeFqvzq2F0LxJIqWJGIVDjhqlBFPBwMxAMRJx6qSCooiEBlCIohGQvB4DgQTAYigRjHrmI+qvyPoJ7uUSM/Bq+PA54wu3CN8+pnqPSEkKESLosnTYN8qsQUiBtpdMJfKQSoG+sTBI01kVx7PUnY8J8SsntCafPTKC8VDQYCkaD+XDQOM+E4hLdAIF4dcmJOVSyQqAwpmCoHQsFYPFYNeVappJOsilUmo2t51edk+GmmyfAzJYyEn2GYDD/r88mwtvvZetopoQgAzzKM4Z8jrqxusNb54l6R0m/6+xF/MHxP4Cufr4Lfx/T9iGVCVsGfJ5x7EfpaLRPwfaJVDPXmG5/bPZOpvXwrpL28QNheCH2tviXeNcIzT/3+eTQDewHJBxatfa1rtvYivM4HvFTPs7WXBM7WFpjx08ups7UF9TBbe4lwtraAcLD6spDZGqXNrwidrb3CNFt7tYSR8KsMs7XXfD5b03a/JmS29rLhSp3v60yztddL1u/hqP1HGRS5ub5IyLXc5LMQ8lwEeAPwJuAtwNuAdwCLAe8C3gO8D/gA8CHgI8DHgE8AnwI+A3wOWAJYCvgC8CXgK8AywHLA14BvAN8CvgOsAHxvemfsc82nNG9d3SKL7g2L7k2L7i2L7m2L7h2LbrFF965F955F975F94FF96FF95FF97FF94lF96lF95lF97lFt8SiW2rRfWHRfWnRfWXRLbPollt0X1t031h031p031l0Kyy670vW/eaVvlJ3eR1v1zpt1vNTisgGlo5aRMjre5/vuGubtS/eICm/tX5903teAXfP8y1CX/zgZ1+EavZ53/Zms4P3jN/xkldg3f3nxYS++NGfvnBS99zfzdLmcHL9/fv3sssrajsL8D6hL37ymy+i9vMPH2Ruc2RDZyk+zDSvyIbPZXxE6Iuf/eOLQG1nUT7OxOZI7edaPkk/rzrPyHxK6Itf/OCLSJ081Wfp2eykYbP6PJ28nLTKTy0h9MWv/64vKtLkqZbWZXMobZvVF7XmFUpmUH7qS0Jf/PZv+SKSEU/11YZtjmZos1q2gbwqkxmXn1pO6IuV9e8LJwue6mubzU5WNqtv1s9LZVl+6ltCX/xen76IZ81TfbeuzUEPNqsVKK9A0lP5qe8JffFHPfnC8XYpwvUBRTi/VXh+5tUXq4T4gnAepAjH8eoXQl/8KcQXhOM9RTheUSsJffGXEF8Q9muKMC6rVYS+WF1PJ4Qcb5cibL+KsP4pyvLT9XcKoNzk973ZE/vO7JF9Y/bMlps9tK/MntoXZo9tidlz+8zswX1i9uQ+Mnt0H5g9u/fMHt5is6f3ttnje9Ps+el9AL2vkHqlHurwWvfmU65xl5Ad6qjXn3/HvB2PF+b7YwkjYZ05db4/EVYGLrt/Qo2CKN81lS0/r36O7c0v4Qn2qWXitQHiivxzCeP3zn+iK5B1vneOSWfIOVbXkTPNWeef6RG7ugr9Z8oVZOKo5parzndylnVBQdnFlJN0KgOwkhOJhSPVlfFAdbQqGUxWBOPBbMu1rspOWa6/MpXrr9mX6/9Fff2NqVx/+4/X15VM5brSlGt9fr2fsvPEnf3vZlDxh+4zODq4nxlGaz8TjyS47M60cTgZ2O15eZC5DB1vl9IVc1UJvW/+ZAoKf9YSbB1vl/qDqSz+YiqLvxjLYj5TWTRt7u+YwtUemv27dtd5tISr7jcnttu9qJceCeulIvS1oiw/PZDSy4+2VYi8DMuzrvqE8+Tos6jKBA8qV9e2CuF4u9Qqpk5gdS2rEHVko+r6P5rzaoagsDFTUMh0byiTwZtXm/8u8WeAofQFrpd/o8FJtv6pq8wp/aO/EOLmpYJBaBvxiErGk8GKSGWgWoWD4XAylIyEo6F4siJUFY8kVKgqGKhMRJykiiYSkYpgLBJOVsZj4SQO2ioeDIbildUxVREIV1U70XiwykmGIkGY8MeDkXg8GA2Hq4LBeDiajFbCJB2m/lGnIhKpdMKBYGWAyz/a3sl5a2fXVJ1CXas5OE8pnUKDUoGdAibN0Sng/N18vTbATX3SKWywEkfWfjOfMujkl/qzU9iUKejkl3rvFOpa2qT0T4FPOwUu/xSU/v8suRaab3gWlVqWXB1v1wb3Oyj3Kj1/24ZwxMnheLcMqZ8zxFWGXvMqLvW3P3SDKWbo2EtKeYJVSSnf8mcRU1mUMpVFaSnvUjBHWWzu86Vgrvawhc+Xgrnq/pZCloIJ66Ui9LXaMrcUnHqt6bOoygQPdhtyzvqLmTqBhoyzfs25IUNQaCVkKRj7zKvNZaX+DDCtmGaVZaX8S8GU/mlEOOvfknDWz+WfRhb/ZHqmpq6lX0r/NGaKn40JyqGu1SnKcmjCVA5NhNWHpkzl0FRYfWjGVA7N0tgq8vPAzkKXrB7jQWNziYPG5syDxuYMg8byeho0ejwVTxrkWhDmRTloLGcalLRIY9Do9XQ9pX9altIN9CgHjVz+aUnQOdZxkT4zYyOy+BllOYj9k1llpd5RoqzjG/t8B0P7eGOG/mYTpr5X51tq3k/JW/+i+p9ufuQ7A/n+57gp9UBSSqXdzufbK9rmTRns3t4nK4p1XOtUTK82b0YYmAnrjaL0BXOQ/Geb4r8YJDf7rwbJzUt5g6Tj7VLa5s059qCZRjRblNY8WZ/j6562EbLj7VKUI+QtfV6f9IxqS4b6tJWAdrQVg91bM7WjrWtpR463iy2m7NT8v1kH2tTTuRavPLchHCQS+lq1YVqh2iY3u2bn2Ip74Egxy2zF0Oh3FTLLbCWg0Xv1RVshAXhbQl8Q1j/VNjdLFxFst6UMtlJ7xSUCHFXOdXiBuhdrTUc0ILVCtS71P8ftpFSo7emIBqVWqO0FVKgdpFSoHemIhqRWqB0FVKidpFSoNnREK6RWqDYCKtTOUirULnREw1Ir1C4CKtSuUipUWzqiEakVqq2ACrWblAq1Ox3RqNQKtbuACrWHlAq1Jx3RSqkVak8BFcqRUqEUHdEqqRVKCahQASkVKkhHtFpqhQoKqFAhKRWqgo5oTGqFqhBQocJSKlSEjmhcaoWKCKhQUSkVqpKOaEJqhaoUUKH2yu3iO6p9kf857i2l5bcjI6ocqRWqnYCWv4+UCtWerkIpsRFKQIXaV0qF6kBXocSeM+ogoELtJ6VC7U9XocSeM9pfQIU6QEqF6khXocSeM+oooEIdKKVCdaKrUGLPGXUSUKEOklKhOtNVKLHnjDoLqFAH59Z3HLUi3/8cu0hp+YfQtXyx53cOEdDyu0qpUN3oKpTY8zvdBFSo7lIqVA+6CiX2/E4PARWqp5QKdShdhRJ7fudQARXqMCkVqhddhRJ7fqeXgArVW0qF6kNXocSe3+kjoEL1lVKh+tFVKLHnd/oJqFCHS6lQ/ekqVFJqheovoEIdwVWhyH8YkfD5RVsRPnTzSKYCpG6QA8h4BiOam35WWGvE9UjzwDstlyN5OyTvgOSdkLwzkndF8m5I3gPJDpIDSA4hOYzkKJL3QvLeSN4HyfsieT8kH4DkA5F8EJIPRnIXJHdFcnck90TyYUjujeS+SD4cyUcgeYCRj4I/RwOOAQwEVAGqATFAHJAAJAHHAgYBBgOOAwwBDAUMAwwHjACMBBwPGAUYDRgDGAsYBzgBMB4wAXAi4CTAxNL1f5+JOmA1oMvLKTf5nAy8JwFOAUwGnAqYAjgNMBUwDXA64AzAmYCzANMBZwPOAZwLOA9wPuACwIWAiwAXAy4BXAq4DHA54ArAlYCrAFcDrjEO1Ha5D488GfnV1U2y6E6x6CZbdKdadFMsutMsuqkW3TSL7nSL7gyL7kyL7iyLbrpFd7ZFd45Fd65Fd55Fd75Fd4FFd6FFd5FFd7FFd4lFd6lFd5lFd7lFd4VFd6VFd5VFd7VFd01pzcN+3Yv6OZC4zXrtx3Tb8JpXIqkvR00qpeO1R3OecUCmPztVm83aF6eQlN9av072nlfA/aHmUwl9saeffRGq+XHqKd5sdvAPXZ/mJa/Auj+aPZXQF44/feGk/lD4tCxtDifX/9Hx07PLK2r7AfMzCH2h/OaLqP1H28/M3ObIhn4A/qxM84ps+MfkpxP6IuAfXwRq4anOzsTmSK02q3PSzytWR/mpcwl9EfSDLyJ18lTnpWezk4bN6vx08nLSKj91AaEvQv+uLyrS5KkurMvmUNo2q4tqzSuUzKD81MWEvqj4t3wRyYinumTDNkcztFlduoG8KpMZl5+6jNAX4fr3hZMFT3W5zWYnK5vVFevnpbIsP3UloS8i9emLeNY81VXr2hz0YLO6GuUVSHoqP3UNoS+iQn4Lg3B9QBHOb5VD+FsYlUJ8QTgPUoTjeBUk9MVeQnxBON5ThOMVFSb0xd5CfEHYrynCuKwqCX3RjskX1PvdhO1XEdY/RVl+7t5guXnF+xGp+xV4PwPvd+D9ELxfgvdT8H4L3o/B+zV4Pwfv9+D9ILxfhPeT8H4T3o/C+1V4Pwvvd+H9MLxfhvfT8H4b3o/D+3V4Pw/v9+H9QLxfiPcT8X7jMCQPR/IIJI9E8vFIHoXk0Ugeg+SxSB6H5BOQPB7JE5B8IpJPQvJEJB+F5KORfAySByK5CsnVSI4hOY7kBJKTSD4WyYOQPBjJxyF5CJKHGtkNKNfCm+sA1wNuANwImAG4CXAz4BbArYDbALcD7gDcCbgLcDfgHsC9gPsAMwGzALMBcwBzAfcDHgA8CHgI8DBgHuARwKOAxwCPA54APAl4CvA04BnAs4DnAM8DXgC8CJgPeAmwAPBy6VqbGufVxET9/o6SvLzVRr4TyZeUrH3NR599BKU/auRXIN9XAa8Bikz+7j34cmNKB/PqeLuU/n9EeTkWulR5B3BZvF669nWhW8HczV6d8FcKAeqOCxeYtw3aZPL1UrqOfyGTI/OJy4/S5kUoLwUL/bBArz8XjcO4Ow5L7IFAvDrkxJyqWCBRGYI1rlAgFIzFY7DoGK1SSSdZFatMRtfy0o2uUV5NA8MXdaNbVEo/yNDXG6WMhN8opc/3TcLKwGX3m6U1BUyUr5UrRQB4s5Q+37eIK6sbrHW+3KfpKIMiN9dXCLmWm3zehjzfASwGvAt4D/A+4APAh4CPAB8DPgF8CvgM8DlgCWAp4AvAl4CvAMsAywFfA74BfAv4DrAC8D3gB8CPgJ8APwN+Mb0z9vnbpeuf0HrHolts0b1r0b1n0b1v0X1g0X1o0X1k0X1s0X1i0X1q0X1m0X1u0S2x6JZadF9YdF9adF9ZdMssuuUW3dcW3TcW3bcW3XcW3QqL7nuL7geL7keL7ieL7meL7pdS/pN/rxD2X2+TDSwd9Q4hr65CTv4tJim/tX5913te/5z8e4/QF92EnPx735vN65z8+8BLXikn/z4k9EV3ISf/PsrSZtvJv4+zy8t68u8TQl/0EHLy79PMbd7gyb/PMs2rlpN/nxP6oqeQk39LMrG5jpN/S9PPq86Tf18Q+uJQISf/vkzP5rRO/n2VTl5pnvxbRuiLw4Sc/Ftel80ZnPz7upTu5N83hL7oJeTk37eldCf/viulO/m3gtAXvYWc/Pu+lO7k3w+ldCf/fiT0RR8hJ/9+KqU7+fdzKd3Jv18IfdFXyKkawvUBRTi/Vd0JT9X0E+ILwnmQIhzHq0MJfXG4EF8QjvcU4XhF9Sb0RX8hviDs1xRhXFb9CH1xhJCTf4TtVxHWP0VZfrr+ngEoN/n9YvbEfjJ7ZD+YPbMVZg/tW7On9rXZY1tm9ty+NHtwen1Br1fodRq97qPXkfT6mV6P0+t7el1Tr5PqdVe93qzXr/V6uN4HeDt1EyRv/UMdXuveq4Tjnl9LyQ51OPV5qAPzdjxemO9vpYyEdebU+a4krAxcdq9EjYIo3zWVLT+vfo7tvVrKE+xTy8RrA8QV+XdU18hPqaykKxCFd5Ex6Qw5x+o6cqY56/wzPWJXV6H/TtgA/yCOam656nwnZ1kXlH5QsHKSTmUAVnIisXCkujIeqI5WJYPJimA8mG251lXZKct1FVO5rsq+XP8v6uufTOX653+8vv7FVK5/mXItQrrUy8+dJ+7sV5tBxd+6z+Do4H5nGK39TjyS4LI708bhZGC351FqQ94ydLxdak3FbEjvmwYNeYKCzneyyZe6LP5mKot8prLIZyyLV5nK4rjm/o4pXO1hyL9rd51HS7jq/lAhS4+E9VIR+lpRlp8eSOnlR9sqRF6G5VlXfcJ5cvRZVGWCB5UFDWtZhXC8XSqPqRPApDPkrOr6P5pzAUNQGOmTvaFMBm9ebS5s6M8AQ+kLXC8L0eAkW//UVeaU/ilCealgENpGPKKS8WSwIlIZqFbhYDicDCUj4WgonqwIVcUjCRWqCgYqExEnqaKJRKQiGIuEk5XxWDiJg7aKB4OheGV1TFUEwlXVTjQerHKSoUgQJvzxYCQeD0bD4apgMB6OJqOVMEmHqX/UqYhEKp1wIFgZ4PJPUcOa2TVVp1DXag7OU0qnUCyxUyhm7hSKGTqFUT7pFDZYiSNrv5lPGXRKfNopjGIKOiUEnUJdS5uU/in1aafA5Z/Shv8/S64NG659LWtoWXJ1vF0b3O+g3Kv0mhfh8q3icLxbhgVCytBrXo0a+tsfusE0YujYGzMNchozLn+WMZVFE6ayaMK8FMxRFmN8vhTM1R7G+nwpmKvujxOyFExYLxWhr9W43FJw6rWmz6IqEzzYbco562/E1Ak0ZZz1a85NGYLCiUKWghsRziqbNfRngDmRaVbZrB6Wgin905xw1j+OcNbP5Z/mFv9keqamrqVfSv+0YIqfLQjKoa7VKcpyaMlUDi2F1YeNmMphI2H1YWOmctg4ja0iPw/sLHTJ6jEeNG4icdC4CfOgcROGQeNEfzxHKFafQW5TwrwoB40TmQYlm6YxaPR6up7SP5s1pBvoUQ4aufyzGUHnWMdF+syMzcniZ5TlIPZKs8pKvaNEWce38PkOhvbxFgz9zZZMfa/Ot9S8PyNv/Yvqf7r5UZf3/Hz/c9yKeiAppdJO8vn2irZ5Kwa7TxHy4JGtCAPz1oSBmbDeKEpfMAfJf7Yp/otBcuv/apDcxudfz9M2b8NgdyumEU2rhjVP1uf4uqdthOx4uxTlCHlbn9cnPaPalqE+lQtoR+UMdrdmaketa2lHjreLLaZMaf7frAOn1dO5Fq88tyMcJBL6Wp3GtEK1XW52zc5xe+6BI8Usc3uGRn+6kFnm9gIavVdfnCEkAO9A6AvC+qfOyM3SRQTbHSiDrdRecYkAR+2Yc5SjWpf6n+NOOUfBEEGAo9rkHAVhRYCjds45CmqrAEftknMUFIIAR+2ac5Sj2gpwVNucoxy1uwBH7ZZzlKP2FOCo3XOOcpQS4Kg9co5yVFCAo/bMOcpRFQIc5eQc5aiIAEepnKMcVSnAUYGcoxzVvkhAP5pzlKPaCWhRoZyjoEUJcFRFzlGO6iDAUeGcoxy1vwBHRXKOclRHAY6K5hzlqE4CHFWZc5SjOgtw1F45RzlqhYBTSHvnHOWoQwS0qHY5RzmqmwBH7ZNzlKN6CHBU+5yjHHWoAEftm3OUo3oJcFSHnKMc1UeAo/bLOcpR/QQ4av+coxzVX4CjDuB6FCX1g+sJH2ahygkfitCR+Evy+juSrZGzO5ov+mp5RyTvhOQ2SN4ZybsgeVckt0XybkjeHcl7IHlPJDtIVkgOIDmI5BCSK5AcRnIEyVEkVyJ5LyTvjeR2SN4Hye2RvC+SOyB5PyTvj+QDkDygdK18IOg6AQ4CdAYcDOgCOATQFdAN0B3QA9ATcCjgMEAvQG9AH0BfQD/A4YD+gCMARwIGAI4CHA04BjAQUAWoBsQA8YbrP5eWOhA0oMvLKTf5JIB3EnAsYBBgMOA4wBDAUMAwwHDACMBIwPGAUYDRgDGAsYBxgBMA4wETACcCTgJMBJwMmAQ4BTAZcCpgCuA0wNSGawsJf2k+gfzq6pIW3bEW3SCLbrBFd5xFN8SiG2rRDbPohlt0Iyy6kRbd8RbdKItutEU3xqIba9GNs+hOsOjGW3QTLLoTLbqTLLqJFt3JFt0ki+4Ui26yRXeqRTfFojvNopvasOYhJ+5F/f133Ga99mOJht7zSqz5DUlHJRvS8ZrenGeAkunjdmuzWfviWJLyW+vXQd7zCrg/UDOY0Bdn+9kXoZof5TnOm80O/oGfIV7yCqz7Y0FDCX1xjj994aT+QNKwLG0OJ9f/saXh2eUVtf1w0whCX5zrN19E7T9WNTJzmyMb+uGr4zPNK7LhH9EaReiL8/zji0BtPxw2OhObI7X/CNmY9POq8wfyxhL64nw/+CJSJ081Lj2bnTRsViekk5eTVvmp8YS+uODf9UVFmjzVhLpsDqVtszqx1rxCyQzKT51E6IsL/y1fRDLiqSZu2OZohjarkzeQV2Uy4/JTkwh9cVH9+8LJgqc6xWazk5XNavL6eaksy0+dSuiLi+vTF/Gseaop69oc9GCzOg3lFUh6Kj81ldAXlwh5BiDh+oAinN+qcwifAXipEF8QzoMU4ThenU/oi8uE+IJwvKcIxyvqIkJfXC7EF4T9miKMy+pSQl9cUU/PKXW8XYqw/SrC+qcoy8/dGyw3r3g/InW/Au9n4P0OvB+C90vwfgreb8H7MXi/Bu/n4P0evB+E94vwfhLeb8L7UXi/Cu9n4f0uvB+G98vwfhreb8P7cXi/Du/n4f0+vB+I9wvxfiLeb+yD5L5I7ofkw5HcH8lHIPlIJA9A8lFIPhrJxyB5IJKrkFyN5BiS40g+EMmdkHwQkjsj+WAkd0HyIUjuiuRuSO6O5B5I7onkQ5F8GJJ7Ibm3kd2AMg3enw44A3Am4CzAdMDZgHMA5wLOA5wPuABwIeAiwMWASwCXAi4DXA64AnAl4CrA1YBrANcCrgNcD7gBcCNgBuAmwM2AWwC3Am4D3A64A3An4C7A3YB7APcC7gPMBMwCzAbMAcxtyH8GYGk+/RmA+4H3A4AHAQ8BHgbMAzwCeBTwGOBxwBOAJwFPAZ4GPAN4FvAc4HnAC4AXAfMBLwEWAF4GvAJ4FfAa4HXAQsAiwBuANxuuLSS8L3t/w/X3ah+w6B606B6y6B626OZZdI9YdI9adI9ZdI9bdE9YdE9adE9ZdE9bdM9YdM9adM9ZdM9bdC9YdC9adPMtupcsugUW3csW3SsW3asW3WsW3esW3UKLbpFF94ZF92ZD/jMAuM16HcPptuE1L/cMwAMN6XjdLuQMwIMk5bfWrw95z+ufMwAPE/riDiFnAOZ5s3mdMwCPeMkr5QzAo4S+uFPIGYDHsrTZdgbg8ezysp4BeILQF3cJOQPwZOY2b/AMwFOZ5lXLGYCnCX1xt5AzAM9kYnMdZwCeTT+vOs8APEfoi3uEnAF4Pj2b0zoD8EI6eaV5BuBFQl/cK+QMwPy6bM7gDMBLDenOACwg9MV9Qs4AvNyQ7gzAKw3pzgC8SuiLmULOALzWkO4MwOsN6c4ALCT0xSwhZwAWNaQ7A/BGQ7ozAG8S+mK2kP01wvUBRTi/VXcS7q/NEeILwnmQIhzHq3sIfTFXiC8Ix3uKcLyiZhL64n4hviDs1xRhXFZzCH3xgJAzAITtVxHWP0VZftx7hZeX0O8VvgVjl7cB7wAWA94FvAd4H/AB4EPAR4CPAZ8APgV8BvgcsASwFPAF4EvAV4BlgOWArwHfAL4FfAdYAfge8APgR8BPgJ8te4VvWfZ03rbo3rHoFlt071p071l071t0H1h0H1p0H1l0H1t0n1h0n1p0n1l0n1t0Syy6pRbdFxbdlxbdVxbdMotuuUX3tUX3jUX3rUX3nUW3wqL73qL7waL70aL7yaL7uSH/XiFus15j/VuEe4VvE85ZnheyV/gO4V7hYsK9wncJffGCkL3C9wj3Ct8n3Cv8gNAXLwrZK/yQcK/wI8K9wo8JfTFfyF7hJ4R7hZ8S7hV+RuiLl4TsFX5OuFe4hHCvcCmhLxYI2Sv8gnCv8EvCvcKvCH3xspC9wmWEe4XLCfcKvyb0xStC9gq/Idwr/JZwr/A7Ql+8KmSvcAXhXuH3hHuFPxD64jUhe4U/Eu4V/kS4V/gzoS9eF7IOT7g+oAjnt+pFwnX4hUJ8QTgPUoTjeLWA0BeLhPiCcLynCMcr6lVCX7whxBeE/ZoijMtqIaEv3hSyV0jYfhVh/VOU5ce9V3g1w17hLzB2+RXwG2Al4HfAH4BVgD8BfwFWA/7W+3plYBMgH1AAKAQUAYoBJYBSQENAGaARoDGgCaApoBmgOaAFoCVgI8DGZXnr7RX+YtnT+dWi+82iW2nR/W7R/WHRrbLo/rTo/rLoVlt0f1t0uvxSdQ0sunyLrsCiK7Toiiy6YouuxKIrtegaWnRlFl0ji66xRdfEomtq0TWz6JpbdC0supYW3UYW3cZl/HuFVxPuFf5CuFf4K+GcZYmQvcLfCPcKVxLuFf5O6IulQvYK/yDcK1xFuFf4J6EvvhCyV/gX4V7hasK9wr8JffGlkL1CPUbIMK8N7hU2yDSvWvYK88vofPGVkL3CgkxsrmOvsDD9vOrcKywi9MUyIXuFxenZnNZeYUk6eaW5V1hK6IvlQvYKG9ZlcwZ7hWVldHuFjQh98bWQvcLGZXR7hU3K6PYKmxL64hshe4XNyuj2CpuX0e0VtiD0xbdC9gpbltHtFW5URrdXuDGhL74Tsg5PuD6gCOe36gvCdfgVQnxBOA9ShON4tYzQF98L8QXheE8RjlfUN4S++EGILwj7NUUYl9UKQl/8KGSvkLD9KsL6pyjLb83+CCo7/f552CtYbeQXkHxgkdkXQp99BKU/auRNYGyxKWAzvS9n8s/PW/+i3pfcrIynXuXR8gzgsti8bO3rFmYP8p9NIZ3wVwoB6gq+GcEgcO1GTjK5OeGAcgsmR+YTlx+lzVuivBQsCMJCnv5cNO6oUByW4gKBeHXIiTlVsUCiMgRz4VAgFIzFY7A4Ea1SSSdZFatMRtfy0o2uUV5NA8MXdaPbsow2GLnXVmWMhHXm1PluTVgZuOzeuqymgInytXKlCABbl9Hnuw1xZXWDtc6X+9QNZVDk5roJIddyk08ryHNbQDmgNWA7wPaAHQA7AnYCtAHsDNgFsCugLWA3wO6APQB7AhyAAgQAQUAIUAEIAyKAKKASsBdgb0A7wD6md8Y+b2U5ybGtRVdu0bW26Laz6La36Haw6Ha06Hay6NpYdDtbdLtYdLtadG0tut0sut0tuj0suj0tOseiUxZdwKILWnQhi67CogtbdBGLLmrRVVp0e1l0e1t07Sy6fcr4TwhtQth/tSIbWDpqW0Je+S1knBAqJym/tX5t7T2vf04IbUfoiwI/+wKdENrem83rnBDawUteKSeEdiT0RaE/fbHeCaGdsrTZdkKoTXZ5WU8I7UzoiyK/+WIDJ4R2ITwhtCvhCaG2hL4o9o8vaj0htBvhCaHdCU8I7UHoixI/+CKNE0J7Ep4QcghPCClCX5T+u75I+4RQgPCEUJDwhFCI0BcN/y1fZHhCqILwhFCY8IRQhNAXZfXvi6xOCEUJTwhVEp4Q2ovQF43q0xceTgjtTXhCqB3hCaF9CH3RuJ584Xi7FOH6gCKc3yo8P/PqiyZCfEE4D1KE43hVQuiLpkJ8QTjeU4TjFVVG6ItmQnxB2K8pwrismhD6ojmTL6gPUBC2X0VY/xRl+en6ez6g3OS3j9kT29vskVWaPbOI2UOrMHtqQbPHpsye255mD253syfX1uzR7WL27NqYPbwdzZ7e9maPr7XZ89P7AHpfIfVKPdThte5tSjjuaV9GdqjDqc9DHZi34/HCfPctYySsM6fOtwNhZWBzFGoURPmuqWz5efVzbG/TMp5gn1omXhsgrsj7obpGfkqlA12BKLyLjElnyDlW15EzzVnnn+kRu7oKfT/CBrg/cVRzy1XnOznLuqCg7GLKSTqVAVjJicTCkerKeKA6WpUMJiuC8WC25VpXZacs1wOYyvWA7Mv1/6K+dmQq147/8fp6IFO5HmjKtQjpUi8/d564s+9kBhUH6T6Do4Pbj2G0th/xSILL7kwbh5OB3V45dmYuQ8fbpXTF7FxG75uDmYLCwbUEW8fbpQ5iKosuTGXRhbEsNmUqi/IW/o4pXO2h9b9rd51HS7jq/nZClh4J66Ui9LWiLD89kNLLj7ZViLwMy7Ou+oTz5OizqMoEDyoPKatlFcLxdinKgQDuBDDpDDmruv6P5ozzd/P1GhR28sneUCaDN682dy3zZ4Ch9AWul9reyXnrXpn6p64yp/RPN5SXCgahbcQjKhlPBisilYFqFQ6Gw8lQMhKOhuLJilBVPJJQoapgoDIRcZIqmkhEKoKxSDhZGY+Fkzhoq3gwGIpXVsdURSBcVe1E48EqJxmKBGHCHw9G4vFgNByuCgbj4WgyWgmTdJj6R52KSKTSCQeClQEu/3Qrq5ldU3UKda3m4DyldArdJXYK3Zk7he4MncLOPukUNliJI2u/mU8ZdHr4tFPYmSno9CDoFOpa2qT0T0+fdgpc/ulZ9v+z5Hpo2drXw8osS66Ot2uD+x2Ue5Ve8yJcvlUcjnfLsEBIGXrNq5fP/aEbTC+Gjr030yCndxnf8udhTGXRh6ks+pTxLgVzlMWuPl8K5moPbX2+FMxV93cTshRMWC8Voa/Vbrml4NRrTZ9FVSZ4sNuXc9bfi6kT6Ms469ec+zIEBUfIUnAvwoFgvzJ/BhiHaVbZrx6Wgin9czjhrH83wlk/l38Ot/gn0zM1dS39UvqnP1P87E9QDnWtTlGWwxFM5XCEsPpwJFM5HCmsPgxgKocBaWwV+XlgZ6FLVo/xoPEoiYPGo5gHjUcxDBoD/niOUKw+g9zRhHlRDhoDTIOSo9MYNHo9XU/pn2PK6AZ6lINGLv8cQ9A51nGRPjNjIFn8jLIcxO5gVt2od5Qo63iVz3cwtI+rGPqbaqa+V+dbat6fn7f+RfU/3fyoy3t+vv85xqgHklIqbcjn2yva5hiD3RVCHjwSIwzMccLATFhvFKUvmIPkP9sU/8UgGf+vBslEGW+QdLxdStucYLA7yTSiSZbVPFmf4+uethGy4+1SlCPkY31en/SM6liG+jRIQDsaxGD3YKZ2NLiWduR4u9hiSrTFf7MOVNbTuRavPI8jHCQS+lpVMq1QHZebXbNzHMI9cKSYZQ5haPTthMwyhwho9F59sY+QADyU0BeE9U/tk5uliwi2QymDrdRecYkARw3LOcpRrUv9z3F4zlGO2l6Ao0bkHOWoHQU4amTOUY5qI8BRx+cc5ahdBDhqVM5RjmorwFGjc45y1O4CHDUm5yhH7SnAUWNzjnKUEuCocTlHOSoowFEn5BzlqAoBjhqfc5SjIgIcNSHnKNjNEeCoE3OOclT7Iv9zPCnnKNjfE9CiJuYcBS1KgKNOzjnKUR0EOGpSzlGO2l+Ao07JOcpRHQU4anLOUY7qJMBRp+Yc5ajOAhw1JecoR60QcArptJyjHHWIgBY1NecoR3UT4KhpOUc5qocAR52ec5SjDhXgqDNyjnJULwGOOjPnKEf1EeCos3KOclQ/AY6annOUo/oLcNTZXI+ipH5wPeHDLNQgwocinEP8JXn9HcnWyNnnmC/6ankYkocjeQSSRyL5eCSPQvJoJI9B8lgkj0PyCUgej+QJSD4RyScheSKST0byJCSfguTJSD4VyVOQfBqSpyJ5GpJPR/IZSD4TyWcheTqSz0bygNK18rmgOw9wPuACwIWAiwAXAy4BXAq4DHA54ArAlYCrAFcDrgFcC7gOcD3gBsCNgBmAmwA3A24B3Aq4DXA74A7AnYC7AHej7/jegOrGmw1reL6B5EVIXojk15H8GpJfRfIrSH4ZyQuQ/BKS5yP5RSS/gOTnkfwckp9F8jNIfhrJTyH5SSQ/geTHkfwYkh9F8iNInofkh5H8EJIfRPIDSL6/Yc3DKzqYV8fjlcsvl18uv1x+ufxy+eXyy+UnK7+Ios0vFKDNT4WI7Y3k6ksuv1x+ufxy+eXyy+WXyy+X338qP+WuBf6M1gV/QvKPSP4Byd8jeQWSv0Pyt0j+BslfI3k5kpch+Sskf4nkL5C8FMlLkPw5kj9D8qdI/gTJHyP5IyR/iOQPkPw+kt9D8rtIXozkd5D8NpLfQvLGaJ1+IyS3RHILJDdHcjMkN0VyEyQ3RnIjJJchuSGSS5FcguRiJBchuRDJBUjOR3IDJOch+W9UDquR/BeS/0TyKiT/geTfkbwSyb8h+Vck/4LkaxGf65B8PZJvQPKNSJ6B5JuQfDOSb0HyrUi+Dcm3I/kOJN+J5LuQfDeSz0XyeUg+H8kXIPlCJF+E5IuRfAmSL0XyZUi+HMlXIPlKJF+F5KuRfI2RZ+atve6B9/cC7gPMBMwCzAbMAcwF3A94APAg4CHAw4B5gEcAjwIeAzwOeALwJOApwNOAZwDPAp4DPA94AfAiYD7gJcACwMuAVwCvAl4DvA5YCFgEeAPwJuAtwNuAdwCLAe8C3gO8D/gA8CHgI8DHgE8AnwI+A3wOWAJYCvgC8CXgK8AywHLA14BvAN8CvgOsAHwP+AHwI+AnwM+AXwC/An4DrAT8DvgDsArwJ+AvwGrA32W6kUMZA/IBBYBCQBGgGFACKAU0BJQBGgEaA5oAmgKaAZoDWgBaAjYCbAzYBLApYDPA5oAtAFsCtgJsDdgG0AqwLaAc0BqwHWB7wA6AHQE7AdoAdgbsAtgV0BawG2B3wB6APQEOQAECgCAgBKgAhAERQBRQCdgLsDegHWAfQHvAvoAOgP0A+wMOAHQEHAjoBDgI0BlwMKAL4BBAV0A3QHdAD0BPwKGAwwC9AL0BfQB9Af0AhwP6A44AHAkY0Gjt7266D7V2L1fuYF697tHPKoF2ULJ+vo63S+k8ifJy8pH9RzVa+3p0I1MY//yeZaO1v0uHdUc3qvmtOq6Coz7MgQvOK0ddJmnmFasjL3V0IzqH1vaDsnkZlmddvHGe1JX8KMIywY38mNTKrRUNUgqI+inVGRhT5w/AHtOIjtfARmSVYZ2fCRjYaP0fsqQu06MJy4GyTKsyKNO6/hcu0ypTpqkNm7rhPUrYu5SbfKqBewwQByQAScCxgEGAwYDjAEMAQwHDAMMBIwAjAccDRgFGA8YAxgLGAU4AjAdMAJwIOAkwEXAyYBLgFF1egFNNg8dlqfn8MwMyrzGLLm7RJSy6pEV3rEU3yKIbbNEdZ9ENseiGWnTDLLrhFt0Ii26kRXe8RTfKohtt0Y2x6MZadOMsuhMsuvEW3QSL7kSL7iSLbqJFd7JFN8miO8Wim2zRnWp0+KL+RYpHCQc21QSxMJHUl6NihHG1gz9+oLxWm7Uv4iTlt9avCe95BdzBWpLQF/v52RehmgHqsd5sdvBgd5CXvALrDpwHE/pif3/6wkmdLByXpc3h5PoTjyHZ5RW1TWKGEvriAL/5ImqfuA3L3ObIhiaBwzPNK7LhCeUIQl909I8vArVNokdmYnOk9gn58YSLEqMIfXGgH3wRqZOnGp2ezU4aNqsx6eTlpFV+aiyhLzr9u76oSJOnGleXzaG0bVYn1JpXKJlB+anxhL446N/yRSQjnmrChm2OZmizOnEDeVUmMy4/dRKhLzrXvy+cLHiqiTabnaxsVievn5fKsvzUJEJfHFyfvohnzVOdsq7NQQ82q8kor0DSU/mpUwl90UXIr3ISrg8owvmt2p/wVzkPEeILwnmQIhzHqwMJfdFViC8Ix3uKcLyiOhP6opsQXxD2a4owLqtDCH3RvZ5+OdjxdinC9qsI65+iLD/uvcJHGPYKp8DY5TTAVMA0wOmAMwBnAs4CTAecDTgHcC7gPMD5gAsAFwIuAlwMuARwKeAywOWAKwBXAq4CXA24BnAt4DrA9YAbADda9gqnWPZ0TrPoplp00yy60y26Myy6My26syy66Rbd2RbdORbduRbdeRbd+RbdBRbdhRbdRRbdxRbdJRbdpRbdZRbd5RbdFRbdlRbdVRbd1RbdNRbdtRbddRbd9RbdDRbdjY349wofIdwrnEK4V3ga4ZzlaCF7hVMJ9wqnEe4Vnk7oi2OE7BWeQbhXeCbhXuFZhL4YKGSvcDrhXuHZhHuF5xD6okrIXuG5hHuF5xHuFZ5P6ItqIXuFFxDuFV5IuFd4EaEvYkL2Ci8m3Cu8hHCv8FJCX8SF7BVeRrhXeDnhXuEVhL5ICNkrvJJwr/Aqwr3Cqwl9kRSyV3gN4V7htYR7hdcR+uJYIXuF1xPuFd5AuFd4I6EvBglZhydcH1CE81s1kHAdfrAQXxDOgxThOF7FCH1xnBBfEI73FOF4RSUJfTFEiC8I+zVFGJfVYEJfDBWyV0jYfhVh/VNDBe0VtqHL65+9whkwdrkJcDPgFsCtgNsAtwPuANwJuAtwN+AewL2A+wAzAbMAswFzAHMB9wMeADwIeAjwMGAe4BHAo4DHAI8DngA8CXjKslc4w7Knc5NFd7NFd4tFd6tFd5tFd7tFd4dFd6dFd5dFd7dFd49Fd69Fd59FN9Oim2XRzbbo5lh0cy26+y26Byy6By26hyy6hy26eRbdIxbdoxbdYxbd4xbdExbdkxbdU4349wpxm/Ua62cQ7hXeRDhnmShkr/Bmwr3CWwj3Cm8l9MXJQvYKbyPcK7ydcK/wDkJfTBKyV3gn4V7hXYR7hXcT+uIUIXuF9xDuFd5LuFd4H6EvJgvZK5xJuFc4i3CvcDahL04Vslc4h3CvcC7hXuH9hL6YImSv8AHCvcIHCfcKHyL0xWlC9gofJtwrnEe4V/gIoS+mCtkrfJRwr/Axwr3Cxwl9MU3IXuEThHuFTxLuFT5F6IvThazDE64PKML5rZpEuA5/hhBfEM6DFOE4Xp1K6IszhfiCcLynCMcraiqhL84S4gvCfk0RxmV1BqEvpgvZKyRsv4qw/imu8qPeJzywSM6e5vMM3398GsZYzwCeBTwHeB7wAuBFwHzAS4AFgJcBrwBeBbwGeB2wELAI8AbgTcBbgLcB7wAWA94FvAd4H/AB4EPAR4CPAZ8APrXsaT5t2Xt6xqJ71qJ7zqJ73qJ7waJ70aKbb9G9ZNEtsOhetuhesehetehes+het+gWWnSLLLo3LLo3Lbq3LLq3Lbp3LLrFFt27Ft17Ft37Ft0HFt2HFt1HFt3HFt0nFt2njfj3NJ8n/P7j04R7ms8Qzq2uErKn+SzhnuZzhHuazxP64mohe5ovEO5pvki4pzmf0BfXCNnTfIlwT3MB4Z7my4S+uFbInuYrhHuarxLuab5G6IvrhOxpvk64p7mQcE9zEaEvrheyp/kG4Z7mm4R7mm8R+uIGIXuabxPuab5DuKe5mNAXNwrZ03yXcE/zPcI9zfcJfTFDyJ7mB4R7mh8S7ml+ROiLm4TsaX5MuKf5CeGe5qeEvrhZyH4B4fqAIpzfqmsI9wtuEeILwnmQIhzHq+sJfXGrEF8QjvcU4XhFzSD0xW1CfEHYrynCuKxuIfTF7UL2NAnbryKsf4qy/HT9vRRQbvL71OyJfWz2yD40e2bvmz20d82e2jtmj+0ts+f2htmDW2j25F4ze3SvmD27BWYPb77Z03vB7PE9Z/b89D6A3ldIvfJTfOq17r1AuA/yGRpDKVjDgbUX/blo3FGhOKyeBALx6pATc6pigURlCKYvoUAoGIvHYD4ZrVJJJ1kVq0xG1+alf8DWbEOud1Hv32LejscL8/28ESNhnTl1vksIB8Fcdi9BjYIo3zWVLT/P/mvJ1Da8UMIT7FPLxGsDxBV5Kapr6xWI14qyhK71KbyLjElnyDlWR+GsaSg6/9RoXBfBugp9KWED/II4qrnlqvOdnGVdUPqJKspJOpUBWMmJxMKR6sp4oDpalQwmK4LxYLblWldlpyzXL5nK9cvsy/X/or5+xVSuX/3H6+sypnJdZsq1COlSLz93nrizX24GFV/rPoOjg1vKMFpb2oh2JMFld6aNw8nAbq8cv2EuQ8fbpXTF/KYRvW++ZQoK39YSbB1vl/qaqSy+YyqL7xjLQgdCjrJ4qIW/YwpXe3j437W7zqMlXHV/npClR8J6qQh9rSjLTw+k9PKjbRUiL8PyrKs+4Tw5+iyqMsGDyhW1rUI43i71DVMnsKKWVYg6slF1/R/NeQVDUHjcJ3tDmQzevNr8fSN/BhhKX+B6+T0anGTrn7rKnNI/P+C9hWAQ2kY8opLxZLAiUhmoVuFgOJwMJSPhaCierAhVxSMJFaoKBioTESepoolEpCIYi4STlfFYOImDtooHg6F4ZXVMVQTCVdVONB6scpKhSBAm/PFgJB4PRsPhqmAwHo4mo5UwSYepf9SpiEQqnXAgWBng8s8PaHZN1SnUtZqD85TSKfwosVP4kblT+JGhU3jSJ53CBitxZM03qJKUQecnn3YKTzIFnZ8IOoW6ljYp/fOzTzsFLv/8/H+05PqLWXL91bbk6ni7NrjfQblX6TUvwuVbxeF4twwLhJSh17x+87k/dIP5jaFjX8k0yFnJuPz5K1NZ/M5UFr8zLwVzlMXTPl8K5moPz/h8KZir7j8rZCmYsF4qQl+rZ3NLwanXmj6LqkzwYPcPzln/b0ydwB+Ms37N+Q+GoPCikKXg3wgHgqsa+TPAvMg0q1xVD0vBlP75k3DW/yzhrJ/LP39a/JPpmZq6ln4p/fMXU/z8i6Ac6lqdoiyH1UzlsFpYffibqRz+FlYf8hrzlIPOV5dDbYNGPw/sLHTJ6jEeNDZoLHDQiElzDBpx/m6+Xiv6S/54jlCsPoNcfmNfrkCol5gGJfmN6x40ej1dT+mfgsZ0Az3KQSOXfwoae+8c67hIn5lRSNY5RlkOYi8xq27UO0qUdbyIboDBsoOhfVzE0N8UMw2sdL6l5v2leetfVP/TzY+6vOfn+59jSWNijlIq7cs+317RNpcw2P2KkAePlBAO6EoJAzNhvVGUvmAOkv9sU/wXg2TpfzVINmzMGyQdb5fSNjdksLuMaURT1rjmyfocX/f8jeHrnpQj5EY+r096RtWIoT41FtCOGjPY3YSpHTWppR053i62mPJ6i/9mHVhYT+davPJsSjhIJPS1Wsi0QtU0N7tm59iMe+BIMctsxtDo3xQyy2wmoNF79cVbQgJwc0JfENY/9VZuli4i2DanDLZSe8UlAhzVIucoR7Uu9T/HljlHOWp7AY7aKOcoR+0owFEb5xzlqDYCHLVJzlGO2kWAozbNOcpRbQU4arOcoxy1uwBHbZ5zlKP2FOCoLXKOcpQS4Kgtc45yVFCAo7bKOcpRFQIctXXOUY6KCHDUNjlHOapSgKNa5RzlqPZF/ue4bc5RjmonoEWV5xwFLUqAo1rnHOWoDgIctV3OUY7aX4Cjts85ylEdBThqh5yjHNVJgKN2zDnKUZ0FOGqnnKMctULAKaQ2OUc56hABLWrnnKMc1U2Ao3bJOcpRPQQ4atecoxx1qABHtc05ylG9BDhqt5yjHNVHgKN2zznKUf0EOGqPnKMc1V+Ao/ZsTM/RStTr98uc7IlWpCo0t83yar6PqN8PAGetNvLRjWrko5CsOaxG9yl4HwAEAaHGNXr3on54/2N0vyakFOETeiqYKhF1+T1OWH4BwvILEz9oIbVuVzSuqcNhJAeRHEqp2xF4HwVUAvZqbH82LvmRGMJyKDf57A15tgPsA2gP2Ff/D8B+gP0BBwA6Ag4EdAIcBOgMOBjQBXAIoCugG6A7oAegJ+BQwGGAXoDegD6AvoB+gMMB/QFHNF5bSPiL+3ubL+5jXTuLbh+Lrr1Ft69F18Gi28+i29+iO8Ci62jRHWjRdbLoDrLoOlt0B1t0XSy6Qyy6rhZdN4uuu0XXw6LradEdatEdZtH1suh6W3R9LLq+Fl0/i+5wi66/RXdE45oHrbgX9XfwI4RxcG+CvBJrfsfSUe0IeS32xyOZa7VZ+2IfkvJb69f23vMKuD+Ssy+hL971sy9CNT8M1MGbzQ7+kaH9vOQVWPcHi/Yn9MV7/vSFk/ojTQdkaXM4uf4PPnXMLq+o7cejDiT0xft+80XU/oNZnTK3ObKhH986KNO8Ihv+Ia/OhL74wD++CNT242UHZ2JzpPYfQuuSfl51/kjfIYS++NAPvojUyVN1Tc9mJw2bVbd08nLSKj/VndAXH/27vqhIk6fqUZfNobRtVj1rzSuUzKD81KGEvvj43/JFJCOe6rAN2xzN0GbVawN5VSYzLj/Vm9AXn9S/L5wseKo+NpudrGxWfdfPS2VZfqofoS8+rU9fxLPmqQ5f1+agB5tVf5RXIOmp/NQRhL74TMhzCAnXBxTh/Fa9R/gcws+F+IJwHqQIx/HqQ0JfLBHiC8LxniIcr6hPCH2xVIgvCPs1RRiX1eeEvvhCyI+wE7ZfRVj/lJTyI/xhC9WYcLxyJPE+rr4mm1f9/tRGNXs8k5F8CpInIflkJE9E8klIPhHJE5A8HsknIHkckscieQySRyN5FJKPR/JIJI9A8nAkD0PyUCQPQfJxSB6M5EFIPhbJSSQnkBxHcgzJ1Ui+Eck3IPl6JF+H5GuRfA2Sr0byVUi+EslXIPlyJF+G5EuRfAmSL0byRUi+EMkXIPl8JJ+H5HORfA6Sz0bydCSfheQzkXwGkk9H8jQkT0XyaUieguSnkPwkkp9A8uNIfgzJjyL5ESTPQ/LDSH4IyQ8i+QEk34/kuUieg+TZSJ6F5JlIvg/J9yL5HiTfjeS7kHwnku9A8u1Ivg3JtyL5FiTfjOSbkDwDyUeiPeYWSG6J5I2QvDGSN0HypkjeDMmbI3kLJG+J5K2QvDWSt0FyKyRvi+RyJLdG8nZI3h7JOyB5RyTvhOQ2SN4ZybsgeVckt0XybkjeHcl7IHlPJOPzEPi8BD5Pgc9b4PMY+LwGPs+Bz3vg8yD4vAg+T4LPm+DzKPi8Cj7Pgs+7HIFkfF4Bn2fA5x3weQh8XgKfp8DnLfB5DHxeA5/nwOc98HkQfF4Enydxz5tckLf2GgDvjwIcDTgGMBBQBagGxABxQAKQBBwLGAQYDDgOMAQwFDAMMBwwAjAScDxgFGA0YAxgLGAc4ATAeMAEwImAkwATAScDJgFOAUwGnAqYAjgNMBUwDXA64AzAmYCzANMBZwPOAZwLOA9wPuACwIWAiwAXAy4BXAq4DHA54ArAlYCrAFcDrgFcC7gOcD3gBsCNgBmAmwA3A24B3Aq4DXA74A7AnYC7AHcD7gHcC7gPMBMwCzAbMAcwF3A/4AHAg4CHAA8D5gEeATwKeAzwOOAJwJOApwBPA54BPAt4DvA84AXAi4D5gJcACwAvA14BvAp4DfA6YCFgEeANwJuAtwBvA94BLAa8C3gP8D7gA8CHgI8AHwM+AXwK+AzwOWAJYCngC8CXgK8AywDLAV83zlvnamBeO5hXx9ulnqI73+hwn/UjPMv6z1m/b6B8vwV8B1gB+B7wA+BHwE+AnwG/AH4F/AZYCfgd8AdgFeBPwF+A1YC/ta+agN2AfEABoBBQBCgGlABKAQ0BZYBGTdYWki4n9/yV5uPGEVf3rUX3nUW3wqL73qL7waL70aL7yaL72aL7xaL71aL7zaJbadH9btH9YdGtsuj+tOj+suhWW3R/W3Tan6m6BhZdvkVXYNEVWnRFFl2xRVdi0ZVadA0tujKLrpHR4Yt6DQm3Wa9zZd02vOblnvX7tjEdr1+FnPX7jqT81vp1hfe8/jnr9z2hL34TctbvB282r3PW70cveaWc9fuJ0BcrhZz1+zlLm21n/X7JLi/rWb9fCX3xu5Czfr9lbvMGz/qtzDSvWs76/U7oiz+EnPX7IxOb6zjrtyr9vOo86/cnoS9WCTnr91d6Nqd11m91Onmledbvb0Jf/CnkrJ+eE9SaVwZn/Ro0oTvrl9+Ezhd/CTnrV9CE7qxfYRO6s35FhL5YLeSsX3ETurN+JU3ozvqVEvribyFn/Ro2oTvrV9aE7qxfI0Jf5LWUcY6GcH1AEc5v1UrCczQNhPiCcB6kCMfxahWhL/KF+IJwvKcIxytqNaEvCoT4grBfU4RxWeG44tUXhUy+oD6rRth+FWH9U5Tlp+vvVYByk18jsyfW0OyRlZg9syKzh1Zg9tT0fEnPv/42e25/mT24VWZP7nezR/eb2bP7xezh/WT29H4we3wrzJ6f3gf4JmWPVV/5KT71WvceJ9wHaYzGUArWcGDtRX8uGndUKA6rJ4FAvDrkxJyqWCBRGYLpSygQCsbiMZhPRqtU0klWxSqT0bV5Femyz6vZq8UX9f4t5u14vDDfJk0YCevMqfNtSjkIZrK7aZOaAibKd01ly89b/6FAHDYQPrjJsdAla4C4IjdDdW29AvFaUZo2IeyV82p2kTHpDDnH6iicNQ1F558ajesiWFehNyNsgM2Jo5pbrjrfyVnWBQVlF1NO0qkMwEpOJBaOVFfGA9XRqmQwWRGMB7Mt17oqO2W5tmAq1xbZl+v/RX1tyVSuLf/j9XUjpnLdyJRrEdKlXn7uPHFnv7EZVGyi+wyODq4Zw2itWRPakQSX3Zk2DicDu71y3JS5DB1vl9IVc9Mm9L7ZjCkobFZLsHW8XWoTprLYnKksNmcsCx0IOcpi45b+jilc7WGTf9fuOo+WcNX9TYUsPRLWS0Xoa0VZfnogZXs0Mb7S/V91HhVBF0efRVUmeFC5RW2rEI63S23K1AlsUcsqRB3ZqLr+j+a8BUNQ2NIne0OZDN4829zEnwGG0he4Xm6JBifZ+qeuMqf0z1Z4byEYhLYRj6hkPBmsiFQGqlU4GA4nQ8lIOBqKJytCVfFIQoWqgoHKRMRJqmgiEakIxiLhZGU8Fk7ioK3iwWAoXlkdUxWBcFW1E40Hq5xkKBKECX88GInHg9FwuCoYjIejyWglTNJh6h91KiKRSiccCFYGuPyzFZpdU3UKda3m4DyldApbS+wUtmbuFLZm6BS29kmnsMFKHFnzDaokZdDZxqedwtZMQWcbgk6hrqVNSv+08mmnwOWfVv9HS67bmiXXctuSq+Pt2uB+B+Vepde8CJdvFYfj3TIsEFKGXvNq7XN/6AbTmqFj345pkLMd4/JnOVNZbM9UFtszLwVzlEUrny8Fc7WHbX2+FMxV98uFLAUT1ktF6GtVnlsKTr3W9FlUZYIHuztwzvpbM3UCOzDO+jXnHRiCwg5CloJbEw4Ed2zizwCzA9Oscsd6WAqm9M9OhLP+csJZP5d/drL4J9MzNXUt/VL6pw1T/GxDUA51rU5RlsPOTOWws7D6sAtTOewirD7sylQOu6axVeTngZ2FLlk9xoPGthIHjW2ZB41tGQaNO9XToNHjqXjSILcbYV6Ug8admAYlu6UxaPR6up7SP7s3oRvoUQ4aufyzO0HnWMdF+syMPcjiZ5TlIHZTs+pGvaNEWcf39PkOhvbxngz9jcPU9+p8S837q/LWv6j+p5sfdXnPz/c/R0U9kJRSaXf2+faKtlkx2L2LkAePKMLAHCAMzIT1RlH6gjlI/rNN8V8MkoH/apAM+vzredrmIIPdIaYRTahJzZP1Ob7uaRshO94uRTlCrvB5fdIzqgqG+hQW0I7CDHZHmNpRpJZ25Hi72GLKbi3/m3Vg93o61+KVZ5RwkEjoa7U70wpVNDe7ZudYyT1wpJhlVnIsCQmZZVYKaPRefaGEBOC9CH1BWP+Uys3SRQTbvSiDrdRecYkAR+2dcxRMq0v9z7FdzlGO2l6Ao/bJOcpROwpwVPucoxzVRoCj9s05CvanBDiqQ85RjmorwFH75RwF83oBjto/5yhYDRfgqANyjoLVGQGO6phzlKOCAhx1YM5RjqoQ4KhOOUc5KiLAUQflHAW7TAIc1TnnKFieKfI/x4NzjoKVaQEtqkvOUdCiBDjqkJyjYB1NgKO65hwFyzMCHNUt5yiY9QtwVPeco2AyKcBRPXKOgjmKAEf1zDnKUSsEnEI6NOcoGPoKaFGH5RwFIyoBjuqVcxR01AIc1TvnKIj/AhzVJ+coCCsCHNU35yiorQIc1S/nKCgEAY46POcoR/UX4Kj+XI+ipH5wPeHDLFSY8KEIRxB/SX7NdyTza5ytv7tVmpNz8n9UPqJJjbw3ktsheR8kt0fyvkjugOT9kLw/kg9AckckH4jkTkg+CMmdkXwwkrsg+RAkd0VyNyR3R3IPJPdE8qFIPgzJvZDcG8l9kNwXyf2QfDiS+yP52tIa+TokX4/kG5B8I5JnIPkmJN+M5FuQfCuSb0Py7Ui+A8l3IvkuJN+N5HuQfC+S70PyTCTPQvJsJM9B8lwk34/kB5D8IJIfQvLDSJ6H5EeQ/CiSH0Py40h+AslPIvkpJD+N5GeQ/CySn0Py80h+AckvInk+kl9C8gIkv4zkaQ1r5NORfAaSz0TyWUiejuSzkXwOks9F8nlIPh/JFyD5QiRfhOSLkXwJki9F8mVIvhzJVyD5SiRfheSrkXwNkq9F8nVIvh7JNyD5RiTPQPJNSL4Zybcg+VYk34bk25F8B5LvRPJdSL4byfcg+V4k34fkmUieheTZSJ6D5LlIHtC4Rj4KyUcj+RgkD0RyFZKrkRxDchzJCSQnkXwskgcheTCSj0PyECQPRfIwJA9H8ggkj0Ty8UgeheTRSB6D5LFIHofkE5A8HskTkHwikk9C8kQkn4zkSUg+BcmTkXwqkqcg+TQkT0XyNCSfjuQzkHwmks9C8nQkn43kc5B8LpLPQ/L5SL4AyRci+SIkX4zkS5B8KZIvQ/LlSL4CyVci+SokX43ka5B8LZKvQ/L1SL4ByTcieQaSb0LyzUi+Bcm3Ivk2JN+O5DuQfCeS70Ly3Ui+B8n3Ivk+JM9E8iwkz0byHCTPRfL9SH4AyQ8i+SEkP4zkeUh+BMmPIvkxJD+O5CeQ/CSSn0Ly00h+BsnPIvk5JD+P5BeQ/CKS5yP5JSQvQPLLSH4Fya8i+TUkv47khUhehOQ3kPwmkt9C8ttIfgfJi5H8LpLfQ/L7SP4AyR8i+SMkf4zkT5D8KZI/Q/LnSF6C5KVI/gLJXyL5KyQvQ/JyJH+N63wZqvNIvg/JM5E8C8mzkTwHyXORfD+SH0Dyg0h+CMkPI3kekh9B8qNIfgzJjyP5CSQ/ieSnkPw0kp9B8rNIfg7JzyP5BSS/iOT5SH4JyQuQ/DKSX0Hyq0h+DcmvI3khkhch+Q0kv4nkt5D8NpLfQfJiJL+L5PeQ/D6SP0Dyh0j+CMkfI/kTJH+K5M+Q/DmSlyB5KZK/QPKXSP4KycuQvBzJXyP5GyR/i+TvkLwCyd8j+Qck/4jkn5D8M5J/QfKvSP4NySuR/DuS/0DyKiT/ieS/kLwayX8jOa9RjdwAyflILkByIZKLkFyM5BIklyK5IZLLkNwIyY2R3ATJTZHcDMnNkdwCyS2RvBGSN0byJkjeFMmbIXlzJG+B5C2RvBWSt0byNkhuheRtkVyO5NZI3g7J2yN5ByTviOSdkNwGyTsjeRck74rktkjeDcm7I3kPJO+JZAfJCskBJAeRHEJyBZLDSI4gOYrkSiTvheS9kdwOyfsguT2S90VyByTvh+T9kXwAkjsi+UAkd0LyQUjujOSDkdwFyYcguSuSuyG5O5J7ILknkg9F8mFI7oXk3kjug+S+SO6H5MOR3B/JRyD5SCQPMPKRsA43AHAU4GjAMYCBgCpANSAGiAMSgCTgWMAgwGDAcYAhgKGAYYDhgBGAkYDjAaMAowFjAGMB4wAnAMYDJgBOBODLbEmQ7cHcWkK3B3MS4d7Qmlht/KDzLc9b+9twZXk1e1r4akBcLp/n0+4n/eO4lIvqf+TyzeWbyzeXby7fXL65fHP55vLN5ZvLN5dvLt9cvrl8c/nm8s3lm8s3l28uX3/kS71eTfn9By6Oewvg2E4Ax30EcGwvgOO+Ajh2EMBxPwEc9xfA8QABHDsK4HigAI6dBHA8SADHzgI4HiyAYxcBHA8RwLGrAI7dBHDsLoBjDwEcewrgeKgAjocJ4NhLAMfeAjj2EcCxrwCO/QRwPFwAx/4COOrnE/id43UCOF4vgOMNAjjeKIDjDAEcbxLA8WYBHG8RwPFWARxvE8DxdgEc7xDA8U4BHO8SwPFuARzvEcDxXgEc7xPAcaYAjrMEcJwtgOMcARznCuB4vwCODwjg+KAAjg8J4PiwAI7zBHB8RADHRwVwfEwAx8cFcHxCAMcnBXB8SgDHpwVwfEYAx2cFcHxOAMfnBXB8QQDHFwVwnC+A40sCOC4QwPFlARz189H9zvF0ARzPEMDxTAEczxLAcboAjmcL4HiOAI7nCuB4ngCO5wvgeIEAjhcK4HiRAI4XC+B4iQCOlwrgeJkAjpcL4HiFAI5XCuB4lQCOVwvgeI0AjtcK4HidAI7XC+B4gwCONwrgOEMAx5sEcLxZAMdbBHC8VQDH2wRwvF0AxzsEcLxTAMe7BHC8WwDHewRwvFcAx/sEcJwpgOMsARxnC+A4RwDHuQI46t9n9jvHowRwPFoAx2MEcBwogGOVAI7VAjjGBHCMC+CYEMAxKYDjsQI4DhLAcbAAjscJ4DhEAMehAjgOE8BxuACOIwRwHCmA4/ECOI4SwHG0AI5jBHAcK4DjOAEcTxDAcbwAjhMEcDxRAMeTBHCcKIDjyQI4ThLA8RQBHCcL4HiqAI5TBHA8TQDHqQI4ThPA8XQBHM8QwPFMARzPEsBxugCOZwvgeI4AjucK4HieAI7nC+B4gQCOFwrgeJEAjhcL4HiJAI6XCuB4mQCOlwvgeIUAjlcK4HiVAI5XC+B4jQCO1wrgeJ0AjtcL4HiDAI43CuA4QwDHmwRwvFkAx1sEcLxVAMfbBHC8XQDHOwRwvFMAx7sEcLxbAMd7BHC8VwDH+wRwnCmA4ywBHGcL4DhHAMe5AjjeL4DjAwI4PiiA40MCOD4sgOM8ARwfEcDxUQEcHxPA8XEBHJ8QwPFJARyfEsDxaQEcnxHA8VkBHJ8TwPF5ARxfEMDxRQEc5wvg+JIAjgsEcHxZAMdXBHB8VQDH1wRwfF0Ax4UCOC4SwPENARzfFMDxLQEc3xbA8R0BHBcL4PiuAI7vCeD4vgCOHwjg+KEAjh8J4PixAI6fCOD4qQCOnwng+LkAjksEcFwqgOMXAjh+KYDjVwI4LhPAcbkAjl9LOFtY5n+O9wrgeJ8AjjMFcJwlgONsARznCOA4VwDH+wVwfEAAxwcFcHxIAMeHBXCcJ4DjIwI4PiqA42MCOD4ugOMTAjg+KYDjUwI4Pi2A4zMCOD4rgONzAjg+L4DjCwI4viiA43wBHF8SwHGBAI4vC+D4igCOrwrg+JoAjq8L4LhQAMdFAji+IYDjmwI4viWA49sCOL4jgONiARzfFcDxPQEc3xfA8QMBHD8UwPEjARw/FsDxEwEcPxXA8TMBHD8XwHGJAI5LBXD8QgDHLwVw/EoAx2UCOC4XwPFrARy/EcDxWwEcvxPAcYUAjt8L4PiDAI4/CuD4kwCOPwvg+IsAjr8K4PibAI4rBXD8XQDHPwRwXCWA458COP4lgONqARz/FsAxr5H/OTYQwDFfAMcCARwLBXAsEsCxWADHEgEcSwVwbCiAY5kAjo0EcGwsgGMTARybCuDYTADH5gI4thDAsaUAjhsJ4LixAI6bCOC4qQCOmwnguLkAjlsI4LilAI5bCeC4tQCO2wjg2EoAx20FcCwXwLG1AI7bCeC4vQCOOwjguKMAjjsJ4NhGAMedBXDcRQDHXQVwbCuA424COO4ugOMeAjjuKYCjI4CjEsAxIIBjUADHkACOFQI4hgVwjAjgGBXAsVIAx70EcNxbAMd2AjjuI4BjewEc9xXAsYMAjvsJ4Li/AI4HCODYUQDHAwVw7CSA40ECOHYWwPFgARy7COB4iACOXQVw7CaAY3cBHHsI4NhTAMdDBXA8TADHXgI49hbAsY8Ajn0FcOwngOPhAjj2F8DxCAEcjxTAcQADRw6et5bw8Pznyk8hHHTCoVAiEkiooKpyApXV0QonVFEdjqqoqohWxAPRYDARDUUjldWVEadShYIJlayoDCbRP6Eyfpc8HuOpbW5AaPOuQmzOJ7S5rRCbCwht3k2IzYWENu9eTzY73i61B2H5fZQvo6PZM08GT0cITyWEZ4CwrmOe1G0ySMjzOyFtMpQng2eFEJ5hITwjQnhGhfCsFMJzLyE89xbCs50QnvsI4dleCM99hfDsIITnfkJ47i+E5wFCeHYUwvNAITw7CeF5kBCenYXwPFgIzy5CeB4ihGdXITy7CeHZXQjPHkJ49hTC81AhPA8TwrMXE08/76v2riebHW+X6kNYfp8JWefumyeDZz8hPA8XwrO/EJ5HCOF5pBCeA4TwPEoIz6OF8DxGCM+BQnhWCeFZLYRnTAjPuBCeCSE8k0J4HiuE5yAhPAcL4XmcEJ5DhPAcKoTnMCE8hwvhOUIIz5FCeB4vhOcoITxHE/Ok5jerJC9vdgn9mueYPLo1z9kl/i/DOQxlOJawDOcIKMO5DGU4jrAM5woow/sZyvAEwjK8n+nLj9Q2jyfLKxiYVeK9/BJJfcWS2Gbq+jMhT0afeqIQnicJ4TlRCM+ThfCcJITnKUJ4ThbC81QhPKcI4XmaEJ5ThfCcJoTn6UJ4niGE55lCeJ4lhOd0ITzPFsLzHCE8zxXC8zwhPM8XwvMCITwvFMLzIiE8LxbC8xIhPC8VwvMyITwvF8LzCiE8rxTC8yohPK8WwvMaITyvFcLzOiE8rxfC8wYhPG8UwnOGEJ43CeF5sxCetwjheasQnrcJ4Xm7EJ53COF5pxCedwnhebcQnvcI4XmvEJ73CeE5UwjPWUJ4zhbCc44QnnOF8LxfCM8HhPB8UAjPh4TwfFgIz3lCeD4ihOejQng+JoTn40J4PiGE55NCeD4lhOfTQng+w8Qzn5jnsygvr9+PmSHk+zHPEdr8eb6M+vh8ngyeLwjh+aIQnvOF8HxJCM8FQni+LITnK0J4viqE52tCeL4uhOdCITwXCeH5hhCebwrh+ZYQnm8L4fmOEJ6LhfB8VwjP94TwfF8Izw+E8PxQCM+PhPD8WAjPT4Tw/FQIz8+E8PxcCM8lQnguFcLzCyE8vxTC8yshPJcJ4blcCM+vhfD8RgjPb4Xw/E4IzxVCeH4vhOcPQnj+KITnT0J4/iyE5y9CeP4qhOdvQniuFMLzdyE8/xDCc5UQnn8K4fmXEJ6rhfD8WwhPnaEEng2E8MwXwrNACM9CITyLhPAsFsKzRAjPUiE8GwrhWSaEZyMhPBsL4dlECM+mQng2E8KzuRCeLYTwbCmE50ZCeG4shOcmQnhuKoTnZkJ4bi6E5xZCeG4phOdWQnhuLYTnNkJ4thLCc1shPMuF8GwthOd2QnhuL4TnDkJ47iiE505CeLYRwnNnITx3EcJzVyE82wrhuZsQnrsL4bmHEJ57CuHpCOGphPAMCOEZFMIzJIRnhRCeYSE8I0J4RoXwrBTCcy8hPPcWwrOdEJ77COHZXgjPfYXw7CCE535CeO4vhOcBQnh2FMLzQCE8OwnheZAQnp2F8DxYCM8uQngeIoRnVyE8uwnh2V0Izx5CePYUwvNQITwPE8KzlxCevYXw7COEZ18hPPsJ4Xm4EJ79hfA8QgjPI4XwHCCE51FCeB4thOcxQngOFMKzSgjPaiE8Y0J4xoXwTAjhmRTC81ghPAcJ4TlYCM/jhPAcIoTnUCE8hwnhOVwIzxFCeI4UwvN4ITxHCeE5WgjPMUJ4jhXCc5wQnicI4TleCM8JQnieKITnSUJ4ThTC82QhPCcJ4XmKEJ6ThfA8VQjPKUJ4niaE51QhPKcJ4Xm6EJ5nCOF5phCeZwnhOV0Iz7OF8DxHCM9zhfA8TwjP84XwvEAIzwuF8LxICM+LhfC8RAjPS4XwvEwIz8uF8LxCCM8rhfC8SgjPq4XwvEYIz2uF8LxOCM/rhfC8QQjPG4XwnCGE501CeN4shOctQnjeKoTnbUJ43i6E5x1CeN4phOddQnjeLYTnPUJ43iuE531CeM4UwnOWEJ6zhfCcI4TnXCE87xfC8wEhPB8UwvMhITwfFsJznhCejwjh+agQno8J4fm4EJ5PCOH5pBCeTwnh+bQQns8I4fmsEJ7PCeH5vBCeLwjh+aIQnvOF8HxJCM8FQni+LITnK0J4viqE52tCeL4uhOdCITwXCeH5hhCebwrh+ZYQnm8L4fmOEJ6LhfB8VwjP94TwfF8Izw+E8PxQCM+PhPD8WAjPT4Tw/FQIz8+E8PxcCM8lQnguFcLzCyE8vxTC8yshPJcJ4blcCM+vhfD8RgjPb4Xw/E4IzxVCeH4vhOcPQnj+KITnT0J4/iyE5y9CeP4qhOdvQniuFMLzdyE8/xDCc5UQnn8K4fmXEJ6rhfD8WwjPvHwZPBsI4ZkvhGeBEJ6FQngWCeFZLIRniRCepUJ4NhTCs0wIz0ZCeDYWwrOJEJ5NhfBsJoRncyE8Wwjh2VIIz42E8NxYCM9NhPDcVAjPzYTw3FwIzy2E8NxSCM+thPDcWgjPbYTwbCWE57ZCeJYL4dlaCM/thPDcXgjPHYTw3FEIz52E8GwjhOfOQnjuIoTnrkJ4thXCczchPHcXwnMPITz3ZOKZn8Iz6IRDoUQkkFBBVeUEKqujFU6oojocVVFVEa2IB6LBYCIaikYqqysjTqUKBRMqWVEZTJq8dyK02aknmx1vl1L5dOV3UhMemwvX93PQA091ZJMUm+PZ5zWgyXrlp7LN66gmdL4Itaw3X6zl6WRn89F2m51s8jpmA+VXmcw8r4GEvqiob1+s5RnN1Oaq2myOZJZXda3lF0pmkleM0Bfhf8cXa3mG0rc5XrfNFenmlUin/Jz08koS+iLyb/piLU8nHZuPTdfmSN15DUq//GJ15TWY0BfRf98Xa3lGarf5uMxsDtSW15BMyy+y4byGEvqi0i++WMszsiGbh2Vjc9Se1/Dsyi9qy2sEoS/28pcv1vAMJ9e3eWT2NjupeR3vpfwC6+Y1itAXe/vQF4ang20e7dXmUE1eY7yXX8DNayyhL9r51xdreCbWElXjmlDkldS5qROI8oLc1HhCX+zjc1+4PCfQrQ8owvmtwvMzrza2rydfON4uRTgPUoTjeBUl9MW+QnxBON5ThOMVtTehLzoI8QVhv6YI47JqT+iL/YT4IkC3hq4IY4EirMuKyxf5xL4IEu4T3FoiY98qlE803osn47X5xmt5Pkdoc4WQPcWwEJ4RITyjQnhWCuG5lxCeewvh2U4Iz32E8GwvhOe+Qnh2EMJzPyE89xfC8wAhPDsK4XmgEJ6dhPA8SAjPzkJ4HiyEZxchPA8RwrOrEJ7dhPDsLoRnDyE8ewrheagQnocJ4dlLCM/eQnj2EcKzrxCe/YTwPFwIz/5CeB4hhOeRQngOEMLzKCE8jxbC8xghPAcK4VklhGe1EJ4xITzjQngmhPBMCuF5rBCeg4TwHCyE53FCeA4RwnOoEJ7DhPAcLoTnCCE8RwrhebwQnqOE8BwthOcYITzHCuE5TgjPE4TwHC+E5wQhPE8UwvMkITwnCuF5shCek4TwPEUIz8lCeJ4qhOcUITxPE8JzqhCe04TwPF0IzzOE8DxTCM+zhPCcLoTn2UJ4niOE57lMPPNTeHr9zmoRoc3nCbG5mNDm84XYXEJo8wVCbC4ltPlCITY3JLT5IiE2lxHafLEQmxsR2nyJEJsbE9p8qRCbmxDafJkQm5sS2ny5EJubEdp8hRCbmxPafKUQm1sQ2nyVEJtbEtp8tRCbNyK0+RohNm9MaPO1QmzehNDm64TYvCmhzdcLsXkzQptvEGLz5oQ23yjE5i0IbZ4hxOYtCW2+SYjNWxHafLMQm7cmtPkWITZvQ2jzrUJsbkVo821CbN6W0ObbhdhcTmjzHUJsbk1o851CbN6O0Oa7hNi8PaHNdwuxeQdCm+8RYvOOhDbfS2izPg/gPkd9F2R/A1MGBSZd75/r/WS9v6r3G/X+m96P0vszer9Cr9/r9Wy9vqvXO/X6n14P0+tDer1Erx/o+bSeX+r5lp5/6PG4Hp/q8Zoev+j+XPdv5QAd/3Q80O1D1xddfvr3UtsAdkY8T8+v4b4roC1gN8DugD0Ae+oyAihAQPsREAJUAMKACCAKqATsBdgb0A6wD6A9YF/jt/0A+wMOAHQEHAjoBDgI0BlwMKAL4BBAV0A3QHdAD0BPwKGAwwC9AL0BfQB9Af0AhwP6A44AHAkYADgKcDTgGMBAQBWgGhAD6Id7JwBJwLGAQYDBgOMAQwBDAcMAwwEjACMBxwNGAUYDxgDGAsYBTgCMB0wAnAg4CTARcDJgEuAUwGTAqYApgNMAUwHTdNkDzgCcCTgLMB1wNuAcwLmA8wDnAy4AXAi4CHAx4BLApYDLAJcDrgBcCbgKcDXgGsC1gOsA1wNuANwImAG4CXAz4BbArYDbALcD7gDcCbgLcDfgHsC9gPsAMwGzALMBcwBzAfcDHgA8CHgI8DBgHuARwKOAxwCPA54APAl4CvA04BnAswD9DPTnAS8AXgTMB7wEWAB4GfAK4FXAa4DXAQsBiwBvAN4EvAV4G/AOYDHgXcB7gPcBHwA+BHwE+BjwCeBTwGeAzwFLAEsBXwC+BHwFWAZYDvga8A3gW8B3gBWA7wE/AH4E/AT4GfAL4FfAb4CVgN8BfwBWAf4E/AVYDfgboINBA0A+oABQCCgCFANKAKWAhoAyQCNAY0ATQFNAM0BzQAtAS8BGgI0BmwA2BWwG2BywBWBLwFaArQHbAFoBtgWUA1oDtgNsD9gBsCNgJ0AbwM6AXQC7AtoCdgPsDtgDsCdABzkFCACCgBCgAhAGRABRQCVgL8DegHaAfQDtAfsCOgD2A+wPOADQEXAgoBPgIEBnwMGALoBDAF0B3QDdAT0APQGHAg4D9AL0BvQB9AX0AxwO6A84AnAkYADgKMDRgGMAAwFVgGpADBAHJABJwLGAQYDBgOMAQwBDAcMAwwEjACMBxwNGAUYDxgDGAsYBTgCMB0wAnAg4CTARcDJgEuAUwGTAqYApgNMAUwHTAKcDzgCcCTgLMB1wNuAcwLmA8wDnAy4AXAi4CHAx4BLApYDLAJcDrgBcCbgKcDXgGsC1gOsA1wNuANwImAG4CXAz4BbArYDbALcD7gDcCbgLcDfgHsC9gPsAMwGzALMBcwBzAfcDHgA8CHgI8DBgHuARwKOAxwCPA54APAl4CvA04BnAs4DnAM8DXgC8CJgPeAmwAPAy4BXAq4DXAK8DFgIWAd4AvAl4C/A24B3AYsC7gPcA7wM+AHwI+AjwMeATwKeAzwCfA5YAlgK+AHwJ+AqwDLAc8DXgG8C3gO8AKwDfA34A/Aj4CfAz4BfAr4DfACsBvwP+AKwC/An4C7Aa8DdADwQaAPIBBYBCQBGgGFACKAU0BJQBGgEaA5oAmgKaAZoDWgBaAjYCbAzYBLApYDPA5oAtAFsCtgJsDdgG0AqwLaAc0BqwHWB7wA6AHQE7AdoAdgbsAtgV0BawG2B3gP69ev1b8Pq30fXvjuvfd9G/K6J/Z0P/7oT+TQf9ewn6twj0c/71M/T18+n1s9/1c9X1M8vXPA8coJ9jrZ8RrZ+/rJ9trJ8brJ/Jq593q58lq5/Tqp+Bqp8vqp/dqZ+LqZ85qZ/nqJ+VqJ9DqJ/xp5+fp59Np5/7pp+ppp9Xpp8Fpp+zpZ9hpZ8PpZ+9pJ9rpJ8ZpJ/HMxCgnyOjn9Gin3+iny2in9uhn4mhnzehn+Wgn5Ogn0Ggv9+vvzuvv5euv/Otv0+tv6usvwesv2Orv7+qvxuqv3epv9Oovy+ov4unv+emv0Omv5+lv/ukv1ekv7Ojvw8zGaC/x6G/I6G/f6DP9utz83rspc9767PU+pyyPgOsz9fqs6v6XKg+J6nPDepzdPpcmT5npc8d6XM4+lyKPqehzy3ofXy9r633efW+p94H1Ptiep9I75vofQS9rq7XmfW6q16H1Otyep1Kr9vodQw9r9fzXD3v0/MgPS+41/jDvVrViGvGnPqqGjMmMWzkmPIxI8qr4vHyEwaPGVQ+YlxiVHLoCD00yivP4p426J525rXXmBGjqo5NlI8eOmJMuVM+HP5WDYXPJ+J7lOO00eXDxo4eUz56TNWoMeXJUSOGlSs9jF0zbs2Uh+5X3GtH89pz1Ihxg4cfWz5ybPXQwbHycVVDxybKBw+PDR07evCI4eXJqsFDE2t+PKYa3byVeY0B5TX/bfToxKgxxwyrGn9M9eAxx4wefKIejq7plzK8ZVjmt4zI/JZRmd8yJvNbTs78llMyv2Va5reckfktZ2d+y7mZ33JZ5rdckfktV2d+y7WZ33Jr5rfcnvkt92Z+y8zMb5mX+S2PZn7Lc5nf8kLmt7yU+S0vZ37LW5nf8k7mt3yY+S0fZ37L55nfsjTzW77L/JbvM7/lp8xv+SXzW1Znfktefsa3FGd+S2nmtzRFt+xmXnuuHSzEq8ZUlY8ZldADhnhifHl8RGL08DZjyodVjYkN0sOP4YnRen1pzaDfax7NCfK4AOWxg3k9eDiMeQbH3QHQkMSE0eWDBg+HwdaIUXoYNcrce6GHey/ycO9l6N50B3rzCmruyXig9yy6Oc068nzmt7yW+S0LM7/lzcxveTvzWz7O/JZPM7/ly8xvWZb5Ld9mfsuKzG9Zmfktf2R+y1+Z3/J35reUFmZ8S1nmtzTP/JaWmd+ydea3tMr8ljaZ37JL5rfslvkte2R+SyTzWyozv2XfzG/ZL/NbDsz8loMyv6Vn5rcclvktfTK/pV/mtwzM/JbqzG8ZlPktx2V+y0h0S7YDrOMJ8hhFkMcKlEemA67vPdz7g4d7f0H3pjvQKy3K/J69itYv3wOqhusVSKgXg4HriYnykSM0w6oxUNDJwcMHj5kAtaa8esKYxOg1q49jUB5pVq9xmd8yPvNbTsz8lkmZ3zI581vOyvyWszO/5YLMb7ko81suy/yWKzK/5cbMb7kp81tuyfyW2zK/5Y7Mb7kr81tmZn7L7MxveSCLmPM4uqf1+vcMGzt0zOCRQyesf+PT2d74fBYsOxXX3JNtZJxcnHGBTsn8lqmZ33J65rdMz/yWczK/5dLMb7k881uuyfyW6zK/ZUbmt9yc+S33ZH7LfZnfMivzW+Zkfsv9md/yYOa3PJr5LY9nfsvT6JZ0Y85L6J6MAtyr2d64KAuWL5bU3JNtZMwvzbhACzO/pTjzW0ozv6Vx5rc0zfyWzTK/ZYvMb2mV+S3lmd+yQ+a37JT5LXtmfovK/JZg5rdUZH5LJPNbKjO/pX3mt3TI/JaO6JZ0Y05XdE9GAa5ntjf2zoLlyZkXxqTMbzkt81umZRE8Gtbckm2U79Uw43/bJ/Nb+mV+S//Mbzkq81uOyfyWQZnfclzmt4zI/JbjM79lbOa3nJD5LZMzv2VK5rdMzfyW0zO/5czMb5me+S3nZ37LhZnfcim6Jd34eS26J6NgfWO2N96SBcv8spp7so2M7coyLtD2md/SIfNb9s/8lk6Z39I581sOzfyWXpnfcnjmtxyR+S1HZ37LwMxvGZz5LUMyv2VY5reMyPyW4zO/ZXTmt4zP/JYTM79lErol3ZhzOronowA3Pdsbz8uC5QMZ3qNPxlWazw3Ny/7ekejeLczrfqNGVU0wW4Mjxo4pH5Esrx4xdnh8NL5xXLY3TsmC7VHmIGAor1aXjB5bPWZUVWzMhjOIZsravbF9tjf2yMLcY8y9KtN/6t64j4d/ul+2//TQLP7pYHNvBN2bkWPdDPbOlPXgbM0d7MHckdk6dqQHx47M1tKRHiyd4NWxE7J17IRszZ3gwdzJXs2dnK25k7M1d7IHc8/Mth6f6aEen5mtpWd6sPQir469KFvHXpStuRd5MPfKbB17pQfHXpmtpVd6sHSGV8fOyNaxM7I1d4YHc+/wau4d2Zp7R7bm3uHB3Pu9Dhjvz3bAeH+2A8b7PQwYH8y22T7oodk+mK1jH/Tg2Ke81uOnsq3HT2Vr7lMezH0xW8e+6MGxL2Zr6YseLF3o1bELs3XswmzNXejB3MVezV2crbmLszV3sQdzP8m2Hn/ioR5/kq2ln3iwdLlXxy7P1rHLszV3uQdzf8jWsT94cOwP2Vr6gwdL//Dq2D+ydewf2Zr7hwdzG+R7NNfNIGNz3Rv3y/bGbMzdxNyLn9XXzrx6ecYIzvvGTA1yb7wt2xvnZFES15p7h3q4N+NVZffGcdnemM2q8hPmS4pZTxLcDDKeJLg3ts/2xmwmCU+ZezMO1e6N2YRq996MG7N7YzaNeYG5N+vY5WaQcexakK25CzyYuyhbxy7y4NhF2Vq6yIOl73t17PvZOvb9bM1934O5n3k197Nszf0sW3M/82Du8mzr8XIP9Xh5tpYu92Dpz14d+3O2jv05W3N/9mDuqmwdu8qDY1dla+kqD5YWmi+fZu1YN4OMHeveuF+2N2ZjbiOv5jbK1txG2ZrbyIO5m5l7sx4wuhlkPGB0b2yf7Y3ZDBi3MPdm3GzdG7Nptltk69gtPDh2e6/1ePts6/H22Zq7vQdzd83Wsbt6cOyu2Vq6qwdLg14dG8zWscFszQ16MHcvr+bula25e2Vr7l4ezN0/23q8v4d6vH+2lu7vwdKuXh3bNVvHds3W3K4ezO2VrWN7eXBsr2wt7eXB0gFeHTsgW8cOyNbcAR7MjXk1N5atubFszY15MPcEcy/HqrKb942ZGuTeeFu2N2azqrw62xa92kOLXp2tz1d78HleUZaWujdmY6l7b8aWujdmY2l+tpbme7A0P1tL8z1Y2ipbS1t5sLRVtpa28mDp8eberKe4bgYZT3HdG9tne2M2U9yTsnXsSR4ce1K2jj3Jg2OnmXuz7nndDDLueadla+40D+ae49Xcc7I195xszT3Hg7kXZ1uPL/ZQjy/O1tKLPVh6rVfHXputY6/N1txrPZh7t1dz787W3LuzNfduD+aebB6qk3X342aQcffj3tg+2xuz6X7OMPdm3GzdG7Nptu69GTvWvTEbx15o7s26HrsZZFyPL8zW3As9mHuFV3OvyNbcK7I19woP5l6fbT2+3kM9vj5bS6/3YOkdXh17R7aOvSNbc+/wYO5DXs19KFtzH8rW3Ic8mPu3eT5b1t2Pm0HG3Y97Y/tsb8ym+2lonm2UcbN1b8ym2br3ZuxY98ZsHLuRuTfreuxmkHE93ihbczfyYO6WXs3dMltzt8zW3C09mNs623rc2kM9bp2tpa09WNrWq2PbZuvYttma29aDuXt5NXevbM3dK1tz9/Jg7sRs6/FED/V4YraWTvRg6WSvjp2crWMnZ2vuZA/m9jTPysp6XOFmkPG4wr2xfbY3ZjOuOMLcm3E9dm/Mph6792bsWPfGbBwbN/dmXY/dDDKux/FszY17MHeIV3OHZGvukGzNHeLB3FHZ1uNRHurxqGwtHeXB0oleHTsxW8dOzNbciR7MPduruWdna+7Z2Zp7tgdzK83DxbLuftwMMu5+3BvbZ3tjNt3PAebejJute2M2zda9N2PHujdm49hu5t6s67GbQcb1uFu25nbzYG5vr+b2ztbc3tma29uDuUdmW4+P9FCPj8zW0iM9WJrw6thEto5NZGtuwoO5Y7yaOyZbc8dka+6YbM1tYj7kBnI9i3J/ildnrE9adTDvHW8X/gkC2ryj4bDOu4SFd2DN7yCU8pSJo1fDDzCZlyAf5Bk/uGnuawOj13B/bqCjJe1AozvQktbJ6DpZ0g4yuoMsaZ2NrrMl7WCjO9iS1sXouljSDjG6Qyxp7k8jdLWkdTO6bpa07kbX3ZLWw+h6WNLcX1ToaUk71F1esKQdZnSHWdJ6GV0vS5r7Qwy9LWl9jK6PJa2v0fW1pPUzun6WtMON7nBLWn+j629JO8LojrCkHWl0R1rSBhjdAEvaUUZ3lCXtaKM72pJ2jNEdY0kbaHQDLWlVRldlSas2umpLWszoYpa0uNHFU9L0W/cHlmnjXGhNLCrkyBvic+O8mtjj8m+M5FL0WsRiX3jND8gU14N9Rci+ohT7dBx2B3UtAUnccbllUrpuPpprkdEVGrh25KP8C0t5bNOc2yF+LmX3h6L0Sxljubq/NlCI/l8J0//jrCONUNnFE9Vjj+064ti8lAu3bVfeDqVjv7t5NbTc2wDd48aO7VJ0hUaPP6uvMpPm1jl3Bl+EykL7xfU/rq/dLen4f+KrEMvIt6U89djR+TVEXAvR/8L/vwz9/wZ0/1/h/+/m7f6vhqh9u3I3VG5lpeuWm1vmLv+mgBIjY/6p9xWn3NcMfaYE3Veacp/73o03uvwOQLLrd113rjGyzPF+JMDWB8GAnzG+rDPed/njeGEb7+v/j/thN61xXk377IjmEO7ET6e743/cn3dC9djVHZTCSevccX4x0h2M/o++2PqVaGjNUK0RR95OIKrzbsKS99oY1jSvpjwL0f9qhMqtGfr/1DGsaUre7v9y9YVI3gp91v2c+xm3DTdB9zc2crNa7itLua8Z+kxjdF+TlPvc9ziGtTCyHou59Xl3oyvN45qbB+Jr+se8da/a+kc8PuYa++j6s7nJ69jEmJ5jq4cOjnWsGlPVe1Qi0W/wmOGJ0aMboP/t8t89hX8Diy3uZ/KRrsBia35KeRSmvC9Juack5T7GOcyatlea8v+Lkayvpnn2OQ1PPVrbHss2wKkUcXLHiGUojWnMHtD5Nd4ApzLEyY1Xjfk5BW3xwMbJ5YJjRZMUnnjsnBqL3Hsap+Tt3sNoYwjH5tpsxPE2z3BqysMp0Dhv3frp/o+8FJ55tXDKo+Pj6HxbsNgaiGpbm2Vgawtka3MWTmvHyVz2NkB5u7a573F/3DJFp+/byMjuGKalpUw2Rp+nHsNslJK3+782Qra4cifE3+WJ24ury0uxBY8z9kV5lCHZLSPXbhwbNlS2+eh+V9cc5VWE7nH/f1cj8/WPa+tD6tg0lQseG8bRZ3sauWleTb9VhmwqtpRPcUr5pK6JrZkTGxnPueoaQ+CYhec2Lu+GSOf6EPdlri9wv9ECye6rW09Kkc6tcyVI53LA5YHHG67OLWtcr1y7cf1w88acXA4tkc61cyP0/5ui/435NEvR2cbt7nvsn6YpnFPnLoSxsKIBKgeXU2qZ4XZXnPKZ5ug+9zPDzCtuq3nIFqbYG8dxx21rzVO44Fh0fC08bTEstd5oP7ll1JLfvqitjyiy2Od+5oSUNHzhNXUc+1LX1N26yL+mHojqNngW4ueWM15Tb8lStuv2f679zVFZ66sZ+gxuG6njy9T9DTxnS20/eH3A/cxp5tXmN9xX4viVGn9S54k4f9xXujoc41K54b4Sr4GfjdLPRffb1sCvtqTnIa55KVz/kXNr4P+UiStfhcrNj2vgFyDZ9buul4cZWeYaeCj8/7gGnsk6Nx7bpK5z47XCBsjPLDaptXPWhhx5OwGHc20KjzXz8tYtL/fC8c+1Ucf6TVB565vcfMpxRqmLce573IEzLfI7jAs5CldUbO+GCq5RSsEVopsKbAWXumJYZik4plVUlenKd+EGOBH2Sk6zvPVXchl3cdaUQeO89MsA73Q0rqNcKKPphlYTtkf/m6uBrRkpoP+JR5KNECf3M23RZ9sYuWmevRcoRp91dQUpn3Nnu7ZVaqZ6qLDNDfLWHdnabHaQHYcgfjw+UclUfoXof6WOFtyy3JDf3M9UmNcNzaCZVqscvCNQlFKueLXK/UxlLTxxXu59bo/l5onrUpN6sq9pGva5n9m3DvtSZ34FFvtSdxYapPzP/DTKgHu3ujCFNy4Dd6UXt6fUOGSzAfcfDZFdDZnswv1AQwtnvhiwboxyyy+1fdcWA3C5u59xV383tHpTZLHV7YN6I5ulzrQKGXkzzeLWmWnhsYHrs9SZVuqsqqPl9NCBKfm1RJ/DY1MWm8xMi+nEh8N5ciPb0yS2mZabTznOKJ1jFyzH0o1xRXnpG1dg4ZSXRztZKLL8r/o4Ap2O/Xh7sWE988xk1mo7ipKXR9tJFtTyvzgmS6lL07qebIf+N09wUU6DlP+JO9dSVPbuZ3ZHn93JyHjrFS+Lp3a+uD7ircuSlHtxfcD3urxKUFk1zVuXv5t3Y5bysg/+CxFHt7zczwTMa7qDf9uxsNRBIz5a1Ajdjz+L21PjOu7DclnKPThmNbL8HzxQTT26lVqPcF0rzttw2bmfcb8+sKEJHk97tPs49VgW9vH+tfCszcdunrj9YB/jhYM8y2exj+u6D8u2SUhqu7T9H7ywpa8O5tXxcsHgCXPCX0/B/ApSuHNPVFJ9lrqYgleRU+tyE3Sf+xl3W2dDE5XUe3H8749szm0JrXP9X24J4f9ThD6L4ymeEFAuEOD41BtxwMcrWcYiZhIlddclk3F26q4LnkS5+ZTjjNLZdeHZcVhbcDyDqcwH/k1SCq7O7arUEQkeCbkFx7ldhaOq+z82ZFx9bVeVWv4f08E5hQ8/plMGzdBr0zrKhXoGljryxttBfA1s7QwMb4XgCIxHEu5n9kCfdbeu8IFVPLNyey08w+qL7rEd6OdcUm+UkndhLXYGEeduiB/T1moylR8e4aeOMFzdhnzlfsZ99tm/sUXVDJUfLle8heN+pl0tPHFe7n1uL4VnhHi0Xh/2NU/DPvczdc3QUg/3Fljsc+3CX7jA/zM/jTKgbk/NU/JOnaXgMjjYvOL2lBp7bDbgPqMR0rkxo8SSL+cRCMzZtTG1DdbWTm1byXXNzlLvxX1DXXEWzwpsK1x45e8VI8uc6VWo/8eZnvaD7aFWhXmZzQI3zatJ5/4CvNa5D7bC4wH3gVZ4VdV9kBWepboPsMJHWLoj+9xX94FV+Asr7oOq3PiAZ7juvY3Q/zs2MeaAQVWDhx8ct81/U0eLqVdKTn0To0YPHjEc31WSZk6MM8RApnMBvOvAc4Bz7dgc/x/3FcdWqv+FD+TjMVZdE1t8Xz3sRDmM/VagueGdurqZuuLO5AMHl2FR3rpt0f2/TMdO1vkCfKHJO3WHB6+W7mpebf1xft76x5Fc/oWWclMV4URVdTIaSgQTVRVOPOQkgsGgEwiEkoF4IBFV4VA0mUxGkyoZScRUdSwcD0QjwVisKpyorKiMM+0Gr8mX6cvT8UzjDZ7/cY3bdD1z69rotb9VfVii6p+gj6tIkxTKDfLWp4+nWzaT8NIPXpwrsHy2tsu2GZD6PBBcRTi6jkILp7wUTqn2MXYdsUzX7fDmEtdaIqe9tpNrqQck8FIXrgup0/CmljJJncZ1ICoT/P/dvN3/1QzZ4sodUZrLE3fXqSc5U7/3qG3cB+VRaCmj1NBdW9niYQAesrqv7rAYHwDoYmTGuhazLdkVpfDjrOt4ueMqxKOHkfEGPZ5OpC794pjr6t33+LvWqZvDtvvc/4efF1KYwX14M9w2LGUqy4DtkJqNk8sFH2ArsdjXIG/dTXicN97cbpxyD6ONa55hU5yGjanPPGDktOaZM0VpcEr9xgUjpwo8LK2NU+ohvvy8dYfWLrfUuoDzzs9bP2bUQ10I28YzNhtdrvi0PROniK1vsXGybVcwcYrivrM2TqnPocjPW/+5dra6gPPOz1v3eRz4HkYbK/F4oDYbU5e+GTlV6fxapMEp9ZkVjJyqdX4t0+CEnwmoLzxVxc+7SK0LePyTn7f+M1/cexqjvHG/jp+z4uo2RuXi6jYxMl4mdJcl8XLiZkbG8cl9vh8ey7m/AoGX/7Y0Mq7P7rMc8fNl3OeB4uczbGNkbD8+KOPqXNs3QjqX68ZI59q0CdK5tuPlWLeMNkM61yebI51bvlsgnVsPtkQ6129bIZ1bRvg5qG4ZuXanfnOw0MIbj93qOlyPx254rMK0jB7H/WfquBhvr7ufmWFeN7Qtl9oX2w4Zu3bheS/TskrMNp/DXFye7mdur8W+NXU7ZZl9zZgIbQPY5kJrlrlKeezTZTkP8zMyfrYM1zPObf1t6pgKP68VL+untgPbuMotx9RvleF25X5mrnnd0LNlbPNafIDZ/Z+NU3ilHj/C38bD8de2ndgF22f88ShKfxzdb3u2zMuW9DzENS+F6z8y8n3u2TJr5QWo3Pz4bJmnkOz6Xfctg40seXu5kJG3n77xiMcs6XzjEW8h47wPsmwXd0b/x9UdjNqZq+ti2S4+xLJd3NWyXdzNsl3c3bJd3AO1E1fXE7UBfeFvc+L5KNc4JtM1d7xewlSH1myftDJ5/fOM7UMSE0bvNzzes2rUmMFVQ/eLx0elPGnbZZnJjgrWF1h07vvU1Rv3fT3siji2Xj+1V8arRyX8nJRtddPGKXXVkHP3CI98auPkcsGjTduqrztzTd28de8pTckbr2Iw2Ri0HSSw2Wh7kjkTpxDeIaiNU+qhCEZOFbYRqY1T6soGXqlIPcCL6wLOOz9v/a8i1kNdsK5u2mx0ueLehImTdXXTxsm2usnEybq6aeOU6epmQcrn3XtsO6PMdcG6ummz0ba6ycTJurpp42Rb3WTiZF3dtHGyrW6mPn3dVhdw3nh1sx7rwpqVm43SsNHlilcWXRmPoN1VRjyCdkfseATtrjLiEbS7yohH0O4qI469eJXRfXVXGfEIeivE39W5q4x4xdVdZcQrru6IEq+4bmtkvOLqlhEuF7f88IqrOwbEsxe33PCKq1tueMXVLTe84uqWGy4Lt9zwiqtbbnjF1S03vOLqlts2SOeWWyukc8vNLYuyvHV39uXNnkMhzvE448x8ndlz6umtkrx121vq51rmrfurZfpqhHwOM6nDqobHRwzrNDgxNJ7OzCf1wi3B9vukbpquQThCCKxB1YxnrCKleXzHenENSp0FaD/Yfie6MM++NoP93RGtmbDM+6Mh9t+eTX14Co7iuIdyI3ZnVA5uXcNfP8A9SRdLa+xiaY3uPcNHjBmcnHDAqETVmES8+4gxCdz4cMXDF16GSN0wcj9fZEnHywellrzwZVsuKdjA59yKk/oYR1yZ8BNs2iIOAoNCJeOil4inO+ChGOX3evD3Ztx7S/PYHgUXwg0/D/0PfBUiuR42lNcserpDROiqYbmzb9XQwfGqMYNHDD8scfzYxOgxeEUz9YnDta12up/JR7q6flcQXw3y6v4dIc5RUW37nu7/xOe4Svg5WVdAbZxsK6BMnKwroDZOma6AFqZ83r2nNCVvPLtlstG6AmqzMXXsg/t/HLLc2RSe3eLZj6trklIGOGzafnMKz25T9+jxTBF/NapFfs3/Fdc9Vq0dv7GE7MDa7rGUp0zW6R5T22t+3oZ/E1qn2b4um2/gdmkHWtLcrrKTJc3tMg+ypLldZ2dLmm1s76a5Y9EuljR3n/MQS5q739nVkubue3azpLn7n90tae4+aA9Lmrsf2tOSdqjRHWpJO8zoDrOk9TK6Xpa03kbX25LWx+j6WNL6Gl1fS1o/o+tnSTvc6A63pPU3uv6WtCOM7ghL2pFGd6QlbYDRDbCkHWV0R1nSjja6oy1pxxjdMZa0gUY30JJWZXRVlrRqo6u2pMWMLmZJixtd3JKWMLqEJS1pdElL2rFGd6wlbZDRDbKkDTa6wZa044zuOEvaEKMbYkkbanRDLWnDjG6YJW240Q23pI0wuhGWtJFGN9KSdrzRHW9JG2V0oyxpo41utCVtjNGNsaSNNbqxlrRxRjfOknaC0Z1gSRtvdOMtaROMboIl7USjO9GSdpLRnWRJm2h0Ey1pJxvdyZa0SUY3yZJ2itGdYkmbbHSTLWmnGt2plrQpRjfFknaa0Z1mSZtqdFMtadOMbpol7XSjO92SdobRnWFJO9PozrSknWV0Z1nSphvddEva2UZ3tiXtHKM7x5J2rtGda0k7z+jOs6Sdb3TnW9IuMLoLLGkXGt2FlrSLjO4iS9rFRnexJe0So7vEknap0V1qSbvM6C6zpF1udJdb0q4wuissaVca3ZWWtKuM7ipL2tVGd7Ul7Rqju8aSdq3RXWtJu87orrOkXW9011vSbjC6GyxpNxrdjZa0GUY3w5J2k9HdZEm72ehutqTdYnS3WNJuNbpbLWm3Gd1tlrTbje52S9odRneHJe1Oo7vTknaX0d1lSbvb6O62pN1jdPdY0u41unstafcZ3X2WtJlGN9OSNsvoZlnSZhvdbEvaHKObY0mba3RzLWn3G939lrQHjO4BS9qDRvegJe0ho3vIkvaw0T1sSZtndPMsaY8Y3SOWtEeN7lFL2mNG95gl7XGje9yS9oTRPWFJe9LonrSkPWV0T1nSnja6py1pzxjdM5a0Z43uWUvac0b3nCXteaN73pL2gtG9YEl70ehetKTNN7r5lrSXjO4lS9oCo1tgSXvZ6F62pL1idK9Y0l41ulctaa8Z3WuWtNeN7nVL2kKjW2hJW2R0iyxpbxjdG5a0N43uTUvaW0b3liXtbaN725L2jtG9Y0lbbHSLLWnvGt27lrT3jO49S9r7Rve+Je0Do/vAkvah0X1oSfvI6D6ypH1sdB9b0j4xuk8saZ8a3aeWtM+M7jNL2udG97klbYnRLbGkLTW6pZa0L4zuC0val0b3pSXtK6P7ypK2zOiWWdKWG91yS9rXRve1Je0bo/vGkvat0X1rSfvO6L6zpK0wuhWWtO+N7ntL2g9G94Ml7Uej+9GS9pPR/WRJ+9nofrak/WJ0v1jSfjW6Xy1pvxndb5a0lUa30pL2u9H9bkn7w+j+sKStMrpVlrQ/je5PS9pfRveXJW210a22pP1tdH9b0v5ZoG64floDV2dJyze6fEtagdEVWNIKja7QklZkdEWWtGKjK7aklRhdiSWt1OhKLWkNja6hJa3M6MosaY2MrpElrbHRNbakNTG6Jpa0pkbX1JLWzOiaWdKaG11zS1oLo2thSWtpdC0taRsZ3UaWtI2NbmNL2iZGt4klbVOj29SStpnRbWZJ29zoNrekbWF0W1jStjS6LS1pWxndVpa0rY1ua0vaNka3jSWtldG1sqRta3TbWtLKja7cktba6Fpb0rYzuu0sadsb3faWtB2MbgdL2o5Gt6MlbSej28mS1sbo2ljSdja6nS1puxjdLpa0XY1uV0taW6Nra0nbzeh2s6TtbnS7W9L2MLo9LGl7Gt2eljTH6BxLmjI6ZUkLGF3AkhY0uqAlLWR0IUtahdFVWNLCRhe2pEWMLmJJixpd1JJWaXSVlrS9jG4vS9reRre3Ja2d0bWzpO1jdPtY0tobXXtL2r5Gt68lrYPRdbCk7Wd0+1nS9je6/S1pBxjdAZa0jkbX0ZJ2oNEdaEnrZHSdLGkHGd1BlrTORtfZknaw0R1sSetidF0saYcY3SGWtK5G19WS1s3oulnSuhtdd0taD6PrYUnraXQ9LWmHGt2hlrTDjO4wS1ovo+tlSettdL0taX2Mro8lra/R9bWk9TO6fpa0w43ucEtaf6Prb0k7wuiOsKQdaXRHWtIGGN0AS9pRRneUJe1oozvaknaM0R1jSRtodAMtaVVGV2VJqza6aktazOhilrS40cUtaQmjS1jSkkaXtKQda3THWtIGGd0gS9pgoxtsSTvO6I6zpA0xuiGWtKFGN9SSNszohlnShhvdcEvaCKMbYUkbaXQjLWnHG93xlrRRRjfKkjba6EZb0sYY3RhL2lijG2tJG2d04yxpJxjdCZa08UY33pI2wegmWNJONLoTLWknGd1JlrSJRjfRknay0Z1sSZtkdJMsaacY3SmWtMlGN9mSdqrRnWpJm2J0UyxppxndaZa0qUY31ZI2zeimWdJON7rTLWlnGN0ZlrQzje5MS9pZRneWJW260U23pP2vlrtqiiqMAzAOCyKlKILd3YLdYt35LRzH8cIYxxs/g93d3d3d3d3d3S0O+Bw94MOVcGZ29uzzO3ti9/r9D6MNExtOGy42gjZCbCRtpNgo2iix0bTRYmNoY8TG0saKjaONExtPGy82gTZBbCJtotgk2iSxybTJYlNoU8Sm0qaKTaNNE5tOmy42gzZDbCZtptgs2iyx2bTZYnNoc8Tm0uaKzaPNE5tPmy+2gLZAbCFtodgi2iKxxbTFYktoS8SW0paKLaMtE1tOWy62grZCbCVtpdgq2iqx1bTVYmtoa8TW0taKraOtE1tPWy+2gbZBbCNto9gm2iaxzbTNYltoW8S20raKbaNtE9tO2y62g7ZDbCdtp9gu2i6x3bTdYntoe8T20vaK7aPtE9tP2y92gHZA7CDtoNgh2iGxw7TDYkdoR8SO0o6KHaMdEztOOy52gnZC7CTtpNgp2imx07TTYmdoZ8TO0s6KnaOdEztPOy92gXZB7CLtotgl2iWxy7TLYldoV8Su0q6KXaNdE7tOuy52g3ZD7Cbtptgt2i2x27TbYndod8Tu0u6K3aPdE7tPuy/2gPZA7CHtodgj2iOxx7THYk9oT8Se0p6KPaM9E3tOey72gvZC7CXtpdgr2iux17TXYm9ob8Te0t6KvaO9E3tPey/2gfZB7CPto9gn2iexz7TPYl9oX8S+0r6KfaN9E/tO+y72g/ZD7Cftp1g2LVvsz2KUxH8tOmhiEVpELIYWIxZLixUrRismFkeLEytOKy4WT4sXS6AliCXSEsWSaEliybRksRK0EmIlaSXFUmgpYqVopcRK00qLpdJSxcrQyoil0dLE0mnpYmVpZcXK0cqJlaeVF6tAqyBWkVZRrBKtklhlWmWxKrQqYlVpVcWq0aqJVadVF6tBqyFWk1ZTrBatllhtWm2xOrQ6YnVpdcXq0eqJ1afVF2tAayDWkNZQrBGtkVhjWmOxJrQmYk1pTcWa0ZqJZdAyxDJpmWLNac3FWtBaiLWktRRrRWsl1prWWqwNrY1YW1pbsXa0dmLtae3FOtA6iHWkdRTrROsk1pnWWawLrYtYFi1LrCutq1g3Wjex7rTuYj1oPUJW0DyN+KgiWhfLxJuimscZnn8RXtofXqoftGBda/B75KynTIn83s9d5k8Ptpx1ssFUpT79+w3pOaD34KGDmInRa2DfqHxbjOwHz5u7Rf56nHwnODaaV7hH8n0/ODbnlhNCz5qWz7P4nPF/W+7a3PSiOXdGeP1+cP82oyeqEK8Z/u3D4xaCa8VG5Z1lH7xHF/69ZIZOmXvN8DVytvDktmi5p8SQFfbYj6SiOXee/zy4/6QC/of8zx7ej4SONbeWLNdJlfYL5+g3oMXVDQA=","debug_symbols":"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","brillig_names":["debug_log_format","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","get_key_validation_request","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_counter"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","get_key_validation_request","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"counters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::initialize_parameters"}}],"kind":"struct","path":"Counter::initialize_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::increment_parameters"}}],"kind":"struct","path":"Counter::increment_abi"}]}},"file_map":{"113":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"114":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"116":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"118":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"120":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"124":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"125":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"128":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"136":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"},"141":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"146":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"147":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"149":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr","source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n"},"151":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"153":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"154":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"162":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n"},"171":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"174":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N, M> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N, M> + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N, M> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"2":{"path":"std/array.nr","source":"use crate::cmp::Ord;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"212":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"22":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"254":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"266":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"286":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"287":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"289":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"293":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"294":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"296":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"297":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"301":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"302":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"303":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n"},"306":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"317":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr","source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_current_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n"},"319":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr","source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"322":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n"},"323":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:TokenNote\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    // docs:start:compute_note_hiding_point\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n    // docs:end:compute_note_hiding_point\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"324":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiller can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"65":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7-i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7-i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"67":{"path":"/Users/niallcheetham/dev/aztec/aztec-private-counter/contracts/counter/src/main.nr","source":"contract Counter {\n\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n\n    //this seems to act like a map in solidity\n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n\n    #[aztec(private)]\n    #[aztec(initializer)]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n        //get_balance operates on the owners counter, is this the owner of the contract or who is calling the function?\n        //yiedls a provate counter that only the owner can decrpyt. \n    }\n}\n\n//checking my understanding\n//the owner of the contract is the person who deployed it with the initaliser\n//      they can give themselves a headstart which is just more tokens on deployment\n//      i still dont understand the difference between owner and outgoing_viewer\n//      because it is private it is just someone who can view the counter, it cannot be anyone\n//      the why are they not present in the get_counter"},"72":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"73":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"75":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"78":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"87":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"89":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"94":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(_self: Self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime { EventSelector::from_signature(\"TestEvent(Field,Field,Field)\") }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"95":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"96":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n"},"97":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"},"99":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n"}}}